name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v0.3.0)'
        required: true
        type: string
      attach_only:
        description: 'Only attach artifacts to existing release (do not modify notes)'
        required: false
        type: boolean
        default: true

permissions:
  contents: write

jobs:
  check-release:
    name: Check Release Existence
    runs-on: ubuntu-latest
    outputs:
      release_exists: ${{ steps.check.outputs.exists }}
      release_id: ${{ steps.check.outputs.id }}
      version: ${{ steps.version.outputs.tag }}

    steps:
      - uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "tag=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Check if release exists
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ steps.version.outputs.tag }}"

          # Try to get release information
          if gh release view "$VERSION" --repo ${{ github.repository }} &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            RELEASE_ID=$(gh api repos/${{ github.repository }}/releases/tags/$VERSION --jq '.id')
            echo "id=$RELEASE_ID" >> $GITHUB_OUTPUT
            echo "Release $VERSION already exists (ID: $RELEASE_ID)"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Release $VERSION does not exist"
          fi

  create-release:
    name: Generate Release Notes
    needs: check-release
    runs-on: ubuntu-latest
    if: needs.check-release.outputs.release_exists == 'false'

    steps:
      - uses: actions/checkout@v4

      - name: Generate dynamic release notes
        id: release_notes
        run: |
          VERSION="${{ needs.check-release.outputs.version }}"
          VERSION_NUM="${VERSION#v}"

          # Calculate project statistics
          TEST_COUNT=$(grep -r "^fn test_" --include="*.rs" crates/ | wc -l)
          LOC=$(find crates -name "*.rs" -exec cat {} \; | wc -l)

          # Try to extract version-specific notes from CHANGELOG.md
          if grep -q "## \[$VERSION_NUM\]" CHANGELOG.md; then
            # Extract notes between this version and the next ## marker
            CHANGELOG_NOTES=$(sed -n "/## \[$VERSION_NUM\]/,/^## \[/p" CHANGELOG.md | sed '$d' | tail -n +2)
          else
            CHANGELOG_NOTES="See [CHANGELOG.md](https://github.com/doublegate/ProRT-IP/blob/main/CHANGELOG.md) for complete version history."
          fi

          # Create comprehensive release notes
          cat > release_notes.md <<EOF
          # ProRT-IP WarScan $VERSION

          Modern network scanner combining Masscan speed with Nmap detection depth.

          ## 📊 Project Statistics

          - **Tests:** $TEST_COUNT+
          - **Lines of Code:** $LOC+
          - **Crates:** 4 (prtip-core, prtip-network, prtip-scanner, prtip-cli)

          ## ✨ Key Features

          - **7 scan types:** TCP Connect, SYN, UDP, FIN, NULL, Xmas, ACK
          - **OS fingerprinting:** 16-probe Nmap sequence with weighted scoring
          - **Service detection:** nmap-service-probes format with 500+ probes
          - **Banner grabbing:** HTTP, FTP, SSH, SMTP, DNS, SNMP (6 protocols + TLS)
          - **Timing templates:** T0-T5 (Paranoid to Insane) with RTT estimation
          - **Adaptive rate limiting:** Masscan-inspired circular buffer with dynamic batching
          - **Decoy scanning:** Up to 256 decoys for stealth attribution hiding
          - **CDN/WAF detection:** 8 major providers with O(log n) lookup
          - **Batch packet sending:** sendmmsg syscall (30-50% performance boost at 1M+ pps)

          ## 📦 Installation

          Download the appropriate binary for your platform below.

          ### Linux (x86_64)
          \`\`\`bash
          # GNU libc (most distributions)
          wget https://github.com/doublegate/ProRT-IP/releases/download/$VERSION/prtip-$VERSION_NUM-x86_64-unknown-linux-gnu.tar.gz
          tar xzf prtip-$VERSION_NUM-x86_64-unknown-linux-gnu.tar.gz
          sudo mv prtip /usr/local/bin/
          chmod +x /usr/local/bin/prtip

          # musl (Alpine, static binary)
          wget https://github.com/doublegate/ProRT-IP/releases/download/$VERSION/prtip-$VERSION_NUM-x86_64-unknown-linux-musl.tar.gz
          tar xzf prtip-$VERSION_NUM-x86_64-unknown-linux-musl.tar.gz
          \`\`\`

          ### Windows (x86_64)
          \`\`\`powershell
          # Download and extract
          curl -L -o prtip-$VERSION_NUM-x86_64-pc-windows-msvc.zip https://github.com/doublegate/ProRT-IP/releases/download/$VERSION/prtip-$VERSION_NUM-x86_64-pc-windows-msvc.zip
          Expand-Archive prtip-$VERSION_NUM-x86_64-pc-windows-msvc.zip

          # Requires Npcap: https://npcap.com/
          \`\`\`

          ### macOS (x86_64)
          \`\`\`bash
          wget https://github.com/doublegate/ProRT-IP/releases/download/$VERSION/prtip-$VERSION_NUM-x86_64-apple-darwin.tar.gz
          tar xzf prtip-$VERSION_NUM-x86_64-apple-darwin.tar.gz
          sudo mv prtip /usr/local/bin/
          chmod +x /usr/local/bin/prtip
          \`\`\`

          ### Build from Source
          \`\`\`bash
          git clone https://github.com/doublegate/ProRT-IP.git
          cd ProRT-IP
          git checkout $VERSION
          cargo build --release
          ./target/release/prtip --help
          \`\`\`

          ## 🔧 Usage Examples

          \`\`\`bash
          # Basic SYN scan
          prtip -sS -p 1-1000 192.168.1.0/24

          # OS detection + service detection
          prtip -sS -O -sV -p 1-1000 10.0.0.1

          # Stealth scan with decoys
          prtip -sF -D RND:10 -p 80,443 target.com

          # Fast scan with progress
          prtip -T4 -p- --progress 192.168.1.1
          \`\`\`

          ## 📚 Documentation

          - **README:** https://github.com/doublegate/ProRT-IP#readme
          - **Documentation:** https://github.com/doublegate/ProRT-IP/tree/main/docs
          - **Architecture:** https://github.com/doublegate/ProRT-IP/blob/main/docs/00-ARCHITECTURE.md
          - **Implementation Guide:** https://github.com/doublegate/ProRT-IP/blob/main/docs/04-IMPLEMENTATION-GUIDE.md
          - **Security:** https://github.com/doublegate/ProRT-IP/blob/main/SECURITY.md

          ## 🔒 Security

          This is a **security research tool** intended for:
          - Penetration testing
          - Network security auditing
          - Educational purposes
          - Red team operations

          **Always obtain proper authorization before scanning networks.**

          See [SECURITY.md](https://github.com/doublegate/ProRT-IP/blob/main/SECURITY.md) for responsible use guidelines.

          ## 📝 Changelog

          $CHANGELOG_NOTES

          ## 🤝 Contributing

          See [CONTRIBUTING.md](https://github.com/doublegate/ProRT-IP/blob/main/CONTRIBUTING.md) for guidelines.

          ## 📄 License

          GPL-3.0 - See [LICENSE](https://github.com/doublegate/ProRT-IP/blob/main/LICENSE)

          ---

          🤖 Generated with GitHub Actions
          EOF

          echo "Generated release notes for $VERSION"
          echo "Statistics: $TEST_COUNT tests, $LOC LOC"

      - name: Create new release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ needs.check-release.outputs.version }}"

          echo "Creating new release $VERSION"
          gh release create "$VERSION" \
            --title "ProRT-IP WarScan $VERSION" \
            --notes-file release_notes.md \
            --repo ${{ github.repository }}

          echo "Release $VERSION created successfully"

  build-release:
    name: Build ${{ matrix.target }}
    needs: [check-release, create-release]
    if: always() && !cancelled() && !failure()
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux - Debian/Ubuntu (glibc) - x86_64
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz

          # Linux - Alpine/Static (musl) - x86_64
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            archive: tar.gz

          # Linux - Debian/Ubuntu (glibc) - ARM64
          - target: aarch64-unknown-linux-gnu
            os: ubuntu-latest
            archive: tar.gz
            cross: true

          # Linux - Alpine/Static (musl) - ARM64
          - target: aarch64-unknown-linux-musl
            os: ubuntu-latest
            archive: tar.gz
            cross: true

          # Windows 10/11 - x86_64
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            archive: zip

          # macOS - Intel x86_64 (older Macs)
          - target: x86_64-apple-darwin
            os: macos-13
            archive: tar.gz

          # macOS - Apple Silicon ARM64 (M1/M2/M3/M4)
          - target: aarch64-apple-darwin
            os: macos-latest
            archive: tar.gz

          # FreeBSD - x86_64 (for BSD users)
          - target: x86_64-unknown-freebsd
            os: ubuntu-latest
            archive: tar.gz
            cross: true

    steps:
      - uses: actions/checkout@v4

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tool
        if: matrix.cross == true
        run: cargo install cross --git https://github.com/cross-rs/cross

      - name: Install musl tools (Linux musl x86_64)
        if: matrix.target == 'x86_64-unknown-linux-musl'
        run: sudo apt-get update && sudo apt-get install -y musl-tools

      - name: Install system dependencies (Linux)
        if: matrix.os == 'ubuntu-latest'
        run: sudo apt-get update && sudo apt-get install -y libpcap-dev pkg-config

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # Install libpcap (only if not already present)
          brew list libpcap &>/dev/null || brew install libpcap
          # pkg-config is provided by pkgconf which is pre-installed on GitHub Actions runners
          brew list pkgconf &>/dev/null || brew install pkgconf

      - name: Install Npcap SDK and Runtime DLLs (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          # Download and extract Npcap SDK (contains Packet.lib for development)
          curl -L -o npcap-sdk.zip https://npcap.com/dist/npcap-sdk-1.13.zip
          Expand-Archive -Path npcap-sdk.zip -DestinationPath npcap-sdk

          # Download Npcap installer and extract DLLs without running (avoids hang)
          curl -L -o npcap-installer.exe https://npcap.com/dist/npcap-1.79.exe

          # Extract installer using 7zip (pre-installed on GitHub Actions)
          7z x npcap-installer.exe -o"npcap-runtime" -y

          # Create runtime directory and copy DLLs
          New-Item -ItemType Directory -Force -Path "npcap-dlls"

          # Find and copy ONLY x64 DLLs (to avoid 32-bit/64-bit architecture mismatch)
          Get-ChildItem -Path "npcap-runtime" -Recurse -Filter "*.dll" | Where-Object {
            ($_.Name -eq "Packet.dll" -or $_.Name -eq "wpcap.dll") -and $_.DirectoryName -like "*x64*"
          } | ForEach-Object {
            Copy-Item $_.FullName -Destination "npcap-dlls\" -Force
            Write-Host "Copied $($_.Name) from $($_.DirectoryName)"
          }

          # Verify we got the x64 DLLs
          if (-not (Test-Path "npcap-dlls\Packet.dll") -or -not (Test-Path "npcap-dlls\wpcap.dll")) {
            Write-Error "Failed to extract x64 DLLs from installer"
            exit 1
          }

          # Add SDK lib directory to LIB environment variable for linking
          echo "LIB=$PWD\npcap-sdk\Lib\x64;$env:LIB" >> $env:GITHUB_ENV

          # Add DLL directory to PATH for runtime
          echo "PATH=$PWD\npcap-dlls;$env:PATH" >> $env:GITHUB_ENV

          # List what we extracted to verify
          Write-Host "Extracted DLLs:"
          Get-ChildItem "npcap-dlls" -ErrorAction SilentlyContinue

      - name: Cache dependencies
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "release-${{ matrix.target }}"

      - name: Build release binary
        run: |
          # Determine build command (cargo or cross)
          if [ "${{ matrix.cross }}" = "true" ]; then
            BUILD_CMD="cross"
          else
            BUILD_CMD="cargo"
          fi

          # Build with appropriate features
          # Enable vendored-openssl for:
          # 1. All musl targets (required for static linking)
          # 2. All cross-compiled ARM targets (OpenSSL detection issues)
          if [[ "${{ matrix.target }}" == *"musl"* ]] || [[ "${{ matrix.cross }}" == "true" && "${{ matrix.target }}" == "aarch64"* ]]; then
            echo "Building with vendored OpenSSL for ${{ matrix.target }}"
            $BUILD_CMD build --release --target ${{ matrix.target }} --locked --features prtip-scanner/vendored-openssl
          else
            $BUILD_CMD build --release --target ${{ matrix.target }} --locked
          fi
        shell: bash
        env:
          # Force static linking for musl targets
          OPENSSL_STATIC: 1

      - name: Create archive (Linux/macOS)
        if: matrix.archive == 'tar.gz'
        run: |
          VERSION="${{ needs.check-release.outputs.version }}"
          VERSION_NUM="${VERSION#v}"
          cd target/${{ matrix.target }}/release
          tar czf ../../../prtip-${VERSION_NUM}-${{ matrix.target }}.tar.gz prtip
          cd ../../..

      - name: Create archive (Windows)
        if: matrix.archive == 'zip'
        shell: pwsh
        run: |
          $VERSION = "${{ needs.check-release.outputs.version }}"
          $VERSION_NUM = $VERSION -replace '^v', ''
          cd target/${{ matrix.target }}/release
          Compress-Archive -Path prtip.exe -DestinationPath $env:GITHUB_WORKSPACE/prtip-${VERSION_NUM}-${{ matrix.target }}.zip

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: prtip-${{ matrix.target }}
          path: prtip-*-${{ matrix.target }}.*
          retention-days: 1

  upload-artifacts:
    name: Upload Artifacts to Release
    needs: [check-release, build-release]
    runs-on: ubuntu-latest
    if: always() && !cancelled() && !failure()

    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display artifact structure
        run: |
          ls -R artifacts/

      - name: Upload to existing or new release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          VERSION="${{ needs.check-release.outputs.version }}"
          RELEASE_EXISTS="${{ needs.check-release.outputs.release_exists }}"
          ATTACH_ONLY="${{ github.event_name == 'workflow_dispatch' && inputs.attach_only || 'true' }}"

          echo "Version: $VERSION"
          echo "Release exists: $RELEASE_EXISTS"
          echo "Attach only: $ATTACH_ONLY"

          # Find all artifact files
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) -print

          if [ "$RELEASE_EXISTS" = "true" ] && [ "$ATTACH_ONLY" = "true" ]; then
            echo "Release $VERSION already exists. Attaching artifacts only (preserving notes)."

            # Upload each artifact to existing release
            find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) | while read file; do
              echo "Uploading $file to existing release $VERSION"
              gh release upload "$VERSION" "$file" --clobber --repo ${{ github.repository }}
            done

          elif [ "$RELEASE_EXISTS" = "true" ]; then
            echo "Release $VERSION exists. Workflow should not modify existing release."
            echo "Skipping upload. Use attach_only=true to add artifacts."

          else
            echo "Uploading artifacts to newly created release $VERSION"

            # Upload artifacts to new release
            find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) | while read file; do
              echo "Uploading $file to new release $VERSION"
              gh release upload "$VERSION" "$file" --clobber --repo ${{ github.repository }}
            done
          fi

          echo "Artifact upload complete"
