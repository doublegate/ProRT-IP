# Naabu: Engineering Speed and Integration in Modern Port Scanning

**Naabu is a Go-based port scanner built by ProjectDiscovery that achieves scanning speeds 3-7x faster than traditional tools through goroutine-based concurrency, raw socket implementation, and automatic IP deduplication.** The tool scans the **top 100 ports by default at 1000 packets per second** using either SYN scanning (with root privileges) or CONNECT scanning (without), and was specifically engineered for bug bounty reconnaissance and web application testing rather than comprehensive security auditing. What makes Naabu technically unique is not raw speed—RustScan and Masscan can both outpace it in certain scenarios—but rather its **intelligent design choices**: automatic IP deduplication when scanning multiple domains, built-in CDN/WAF detection, seamless integration with ProjectDiscovery's reconnaissance toolchain, and the ability to hand off discovered ports directly to Nmap for detailed service enumeration.

ProjectDiscovery, the organization behind Naabu, evolved from a side project into a funded company in 2021, raising $25 million in Series A funding and building a global community of over 100,000 engineers. The company's philosophy centers on the Unix principle of creating focused tools that excel at specific tasks and integrate seamlessly. Naabu sits strategically between asset discovery and vulnerability assessment in their ecosystem, designed to receive subdomain lists from Subfinder, scan for open ports with maximum efficiency, then feed results to httpx for HTTP probing and Nuclei for vulnerability detection. This focused positioning explains many of Naabu's design decisions—it deliberately omits features like OS fingerprinting and comprehensive service detection that would slow execution, instead providing a clean handoff mechanism to Nmap when such analysis is needed.

## Architecture decisions that prioritize concurrency over feature completeness

Naabu's implementation leverages Go's concurrency model as its primary performance advantage. The scanner employs **25 goroutines by default** (configurable via the `-c` flag), with each goroutine representing a lightweight worker thread that can scan multiple ports and hosts simultaneously. Unlike traditional OS threads that carry significant memory overhead, Go's goroutines enable massive parallelism—developers report successfully running configurations with 100+ concurrent workers on cloud VPS instances without memory exhaustion. The tool manages packet transmission at a default rate of **1000 packets per second**, though production users commonly increase this to 5000-7000 pps on well-connected servers for optimal performance.

The scanning engine supports three distinct methodologies, each with different performance and privilege characteristics. **SYN scanning** (half-open scanning) serves as the default when executed with root privileges, crafting custom TCP packets with the SYN flag set and capturing responses via libpcap without completing the three-way handshake. This approach operates 3-5x faster than full connection establishment and remains stealthier because many systems don't log incomplete handshakes. When root access is unavailable, Naabu automatically falls back to **CONNECT scanning**, which establishes complete TCP connections through the operating system's networking stack. While slower, CONNECT scanning works through proxies and requires no special privileges. The third methodology, **UDP scanning**, sends empty probe packets to specified ports, though this remains inherently less reliable due to UDP's stateless nature and the common practice of silently dropping UDP packets at firewalls.

The network-level implementation reveals sophisticated packet handling through the gopacket library, which wraps the C-based libpcap in Go-friendly abstractions. For SYN scans, Naabu constructs packets at the network layer by manually building Ethernet, IP, and TCP layers with proper checksums, then transmits them via raw sockets (AF_PACKET, SOCK_RAW on Linux). Response capture occurs directly through libpcap with Berkeley Packet Filter (BPF) rules that minimize context switches between kernel and user space. The scanner interprets SYN-ACK responses as open ports, RST responses as closed ports, and absence of response as filtered ports. A critical optimization introduced in version 2.3.0 shares packet capture handlers globally rather than creating new handlers for each target, preventing resource leaks and improving efficiency when scanning large host lists.

Naabu's most innovative algorithmic contribution addresses a practical pain point in web application reconnaissance: **automatic IP deduplication**. When security researchers enumerate subdomains for a target organization, dozens or hundreds of subdomains often resolve to identical IP addresses due to shared hosting infrastructure, load balancers, or CDN services. Traditional scanners would wastefully scan the same IP address repeatedly. Naabu instead resolves all provided domains to IP addresses, maintains a hash-based tracking system, and scans each unique IP exactly once—a workflow optimization that no equivalent exists in Nmap, Masscan, or RustScan. Combined with the **CDN/WAF exclusion feature** (triggered via `-exclude-cdn`), which recognizes infrastructure from Cloudflare, Akamai, Incapsula, and Sucuri and limits these IPs to only ports 80 and 443, this intelligence prevents hours of wasted scanning effort against heavily protected edge infrastructure.

## Default execution behavior reveals VPS-optimized assumptions

Understanding Naabu's default settings illuminates its design priorities and target deployment environment. When executed without any flags, the scanner operates with **VPS-centric assumptions** that may require tuning for local network scanning. The default port selection scans **Nmap's top 100 most common ports** rather than a sequential range or all 65,535 ports, prioritizing speed over comprehensive coverage. This list includes standard services like HTTP (80, 443, 8080, 8443), SSH (22), FTP (21), databases (3306, 5432, 1433, 27017), and remote access protocols (3389).

The timing parameters establish a moderate baseline: **1000 packets per second** transmission rate, **25 worker threads**, and a **2-second warm-up time** between scan phases. These defaults work well on dedicated servers with good network connectivity but often prove too aggressive for residential connections or too conservative for high-bandwidth cloud environments. The scanner includes a configurable timeout value (supporting formats like "5s" or "100ms") and implements **automatic retry logic** with 3 default attempts per failed probe. Notably, version 2.3.4 introduced a significant performance regression where CPU utilization dropped below 1% in Docker environments, causing scan times to balloon from minutes to hours—leading the community to recommend version 2.3.3 as the most stable release as of February 2025.

Host discovery runs automatically when sufficient privileges exist, using multiple probe types including ARP ping for local networks, TCP SYN/ACK pings to common ports, ICMP echo requests, and IPv6 neighbor discovery. This pre-scan phase identifies active hosts before attempting port enumeration, avoiding wasted probes against offline systems. Users can disable this behavior with the `-Pn` flag or perform host discovery exclusively without port scanning via `-sn`. The scanner defaults to IPv4-only operation but supports IPv6 through the `-ip-version 6` flag, and can scan both protocol versions simultaneously with `-ip-version 4,6 -scan-all-ips`.

Output defaults to simple text format directed to stdout, displaying results as `host:port` pairs with informational messages about scan progress. Silent mode (`-silent`) strips these informational messages for clean pipeline integration, while JSON mode (`-json` or `-j`) emits one JSON object per line in the format `{"ip":"104.16.99.52","port":443}`, ideal for parsing by automation scripts. The configuration system checks `$HOME/.config/naabu/config.yaml` for persistent settings, allowing teams to standardize scanning parameters across an organization. The scanner also exposes a metrics API endpoint at localhost:63636 during execution for monitoring scan progress and performance characteristics.

## Performance benchmarks show context-dependent results versus competing scanners

Real-world testing reveals that Naabu occupies a middle ground in the performance spectrum—not the absolute fastest scanner available, but fast enough for practical reconnaissance while offering superior usability and integration. In the comprehensive Port Scanner Shootout benchmark series, **RustScan dominated all three test scenarios** for pure speed, completing a full 65,535-port TCP scan in approximately 8 seconds on a test VPS compared to Naabu's 488 seconds (8+ minutes) in the same configuration. However, these results varied significantly based on settings: Naabu with optimized parameters (7000 pps, 100 threads, 250ms timeout) completed remote host scans in 10-11 seconds versus 28-32 seconds at default settings. Against a local Metasploitable3 target, Naabu finished full port enumeration in 12-15 seconds while maintaining **100% accuracy** (13/13 ports detected).

The speed-accuracy tradeoff manifests clearly in rate limiting tests. Community testing established that **7000 packets per second represents the optimal balance** for Naabu—at this rate, accuracy remains at 100% while scan times stay competitive. Pushing beyond 8000 pps causes accuracy to degrade noticeably, while conservative rates like 3000 pps extend subnet scans from 6 seconds to nearly 12 seconds without improving detection rates. The false positive problem becomes particularly acute at aggressive settings, leading experienced users to always include the `-verify` flag, which establishes full TCP connections to confirm ports identified during the initial SYN scan, roughly doubling scan time but dramatically reducing spurious results.

Compared to **Nmap**, the traditional port scanning standard, Naabu delivers 3-5x faster initial port discovery. A typical scan might complete in 7 seconds with Naabu versus 20 seconds with Nmap, though this comparison narrows significantly when Nmap enables timing templates like `-T4` or `-T5`. The critical distinction lies not in raw speed but in feature scope: Nmap provides OS fingerprinting, version detection, vulnerability scanning via NSE scripts, multiple scan types (FIN, NULL, Xmas, ACK, Window, Maimon), and decades of maturity. Naabu deliberately omits these capabilities, instead offering a `-nmap-cli` flag that pipes discovered ports directly to Nmap for detailed analysis. This two-phase approach—fast port discovery with Naabu followed by targeted service enumeration with Nmap—combines the strengths of both tools.

Against **Masscan**, designed specifically for internet-scale scanning at up to 10 million packets per second theoretical maximum, Naabu offers greater ease of use and built-in features at the cost of raw throughput. Masscan excels at scanning massive IP ranges where speed is paramount, while Naabu handles domain-based scanning more gracefully through DNS resolution and IP deduplication. Critically, a 2022 developer review noted that "Naabu's own port scanning engine is multiple times slower than Masscan," positioning Masscan as the superior choice when scanning thousands of hosts across internet address space. However, Masscan lacks native DNS support, scripting capabilities, and the seamless integration that makes Naabu effective in reconnaissance pipelines.

**Zmap** serves an entirely different purpose despite superficial similarity—it's optimized for research studies requiring internet-wide scanning, capable of surveying the entire IPv4 space in under 6 minutes when paired with Zgrab2 for application-level detail. However, Zmap explicitly states it's "not intended to be used to scan all open ports for a target," supporting only specific port queries across massive IP ranges. This makes Zmap and Naabu complementary rather than competitive: researchers use Zmap for longitudinal studies of internet services, while penetration testers use Naabu for comprehensive per-target reconnaissance.

## Integration patterns that define modern reconnaissance workflows

Naabu's true value emerges not from standalone operation but from its role in multi-tool pipelines. The ProjectDiscovery ecosystem follows a clear workflow pattern: **Subfinder** performs passive subdomain enumeration, **Naabu** identifies open ports, **httpx** probes HTTP services and captures metadata, and **Nuclei** scans for known vulnerabilities using its library of 9,000+ community-curated templates. This pipeline executes efficiently through Unix-style composition:

```bash
subfinder -d target.com -silent | 
naabu -p 80,443,8080,8443 -silent | 
httpx -silent -title -tech-detect | 
nuclei -t cves/ -severity critical,high -silent
```

The **silent mode** (`-silent`) strips informational messages, outputting only discovered ports in clean `host:port` format perfect for piping. JSON output mode produces one valid JSON object per line (JSON Lines format), enabling sophisticated filtering through tools like jq: `naabu -json -silent | jq -r 'select(.port == 443) | "\(.ip):\(.port)"'`. This structured output facilitates integration with SIEM systems, ticketing platforms, monitoring dashboards, and custom automation scripts.

The **Nmap integration** demonstrates Naabu's philosophy of delegation rather than reimplementation. Using the `-nmap` flag or `-nmap-cli` parameter, Naabu hands discovered ports directly to Nmap for service version detection: `naabu -host target.com -p - -nmap-cli 'nmap -sV -sC -oA services'`. This approach leverages Nmap's mature fingerprinting without forcing Naabu to reimplement decades of signature development. However, users report that this integration breaks when scanning large host/port combinations and doesn't produce standard XML output formats, requiring workarounds for enterprise environments needing structured reporting.

Bug bounty hunters have developed standardized reconnaissance patterns leveraging Naabu's strengths. A typical comprehensive workflow begins with subdomain enumeration from multiple sources (Subfinder, Amass, certificate transparency logs), deduplicates results, performs full-port Naabu scanning with verification enabled and CDN exclusion active, probes all discovered services with httpx to identify web applications, takes screenshots of interesting pages, then runs Nuclei vulnerability scans filtered to critical and high severity findings. The entire pipeline can execute unattended, with results piped to notification systems (Discord, Slack, Telegram via the **Notify** tool) when high-severity issues are discovered:

```bash
subfinder -d target.com -all -silent | 
naabu -p - -verify -exclude-cdn -rate 7000 -silent | 
httpx -silent -title -tech-detect -screenshot | 
nuclei -t cves/,exposures/ -severity critical,high -json | 
jq -r 'select(.info.severity=="critical")' | 
notify -provider telegram
```

DevSecOps teams integrate Naabu into CI/CD pipelines for continuous security monitoring. GitHub Actions, GitLab CI, and Jenkins jobs can execute scheduled scans, compare results against baseline configurations, and alert on infrastructure changes. A typical implementation establishes a baseline port configuration for production hosts, runs daily Naabu scans, diffs the current state against the baseline, and triggers alerts when new services appear or expected services disappear. This continuous monitoring approach identifies shadow IT, misconfigurations, and unauthorized services before they become security incidents.

## Practical deployment scenarios reveal operational tradeoffs

Understanding when to deploy Naabu versus alternatives requires mapping tool capabilities to specific scenarios. **Bug bounty hunting** represents Naabu's core strength—the IP deduplication feature alone can reduce scan time by 80% when working with subdomain lists that resolve to shared infrastructure. The typical bug bounty scope includes hundreds or thousands of subdomains, most resolving to a handful of IP addresses behind load balancers or CDN services. A naive approach scanning each subdomain independently wastes hours; Naabu's automatic deduplication turns a 4-hour scan into 45 minutes while maintaining identical coverage.

For **penetration testing engagements**, the optimal approach depends on the assessment phase. Initial reconnaissance benefits from Naabu's speed, identifying the attack surface rapidly: `naabu -list scope.txt -p - -verify -rate 5000 -exclude-cdn -o discovered-ports.txt`. Once open ports are identified, pivot to Nmap for detailed enumeration: `nmap -iL discovered-ports.txt -sV -sC -O -oA detailed-scan`. This two-phase methodology completes initial discovery in minutes rather than hours, allowing more time for exploitation and analysis. However, for small scopes with few hosts, directly using Nmap with aggressive timing (`-T4`) may prove simpler than maintaining two-tool workflows.

**Network reconnaissance** across enterprise environments requires careful configuration to avoid triggering intrusion detection systems or overwhelming network links. Recommended settings reduce packet rates to 500-1000 pps, enable multiple retries, increase timeouts, and disable aggressive optimizations: `naabu -list internal-network.txt -rate 500 -c 25 -retries 3 -timeout 2000 -verify`. The host discovery features become valuable here—ARP ping for local subnet mapping, TCP SYN ping to specific ports for remote network enumeration, and ICMP echo requests where firewall rules permit. Running host discovery as a separate phase (`-sn`) before port scanning improves efficiency by focusing on active systems.

**Security auditing and compliance** scenarios demand accuracy over speed. Configuration should emphasize verification, multiple retries, conservative timing, and comprehensive logging: `naabu -list assets.txt -p - -verify -retries 5 -timeout 3000 -rate 1000 -json -o audit-$(date +%Y%m%d).json`. The JSON output facilitates compliance reporting, with timestamps and structured data meeting audit requirements. Comparing scans over time identifies configuration drift and unauthorized changes, supporting ISO 27001, PCI-DSS, and SOC 2 control objectives around asset management and change detection.

**Cloud and DevSecOps integration** leverages Naabu's lightweight resource footprint and fast execution for continuous monitoring. Docker containers running scheduled scans consume minimal CPU and memory, typically under 100MB RAM at default settings. Integration with **CloudList** enables scanning across multiple cloud providers: `cloudlist -providers aws,gcp,azure -silent | naabu -p - -verify -silent | httpx -silent | nuclei -t cloud/`. This workflow discovers exposed cloud assets, identifies open ports, checks for HTTP services, and scans for cloud-specific vulnerabilities like open S3 buckets, misconfigured storage accounts, and exposed management interfaces.

## Technical limitations and operational considerations that impact deployment decisions

Naabu's design tradeoffs manifest as concrete limitations in certain scenarios. The **requirement for root privileges** to perform SYN scanning represents the most immediate constraint—without sudo or administrator access, the scanner falls back to CONNECT scans that establish full TCP connections, roughly tripling scan time and increasing visibility to intrusion detection systems. On shared hosting environments or restricted corporate systems where privilege escalation is impossible, Naabu's performance advantage largely disappears. The automatic fallback provides graceful degradation, but users should understand the performance implications.

**Platform dependencies** create deployment friction, particularly the libpcap requirement. Linux systems typically include libpcap by default, but manual installation (`sudo apt install libpcap-dev`) is required on fresh installations. macOS users need Homebrew or MacPorts to install libpcap, and certain features like source IP specification don't function correctly due to gopacket limitations on Darwin systems. Windows support remains problematic enough that the official recommendation suggests using Docker containers rather than native installation, adding deployment complexity for Windows-centric security teams.

The **absence of native service detection** means Naabu cannot answer the question "What service and version is running on this port?" without external help. While the Nmap integration provides this capability, it creates a two-tool dependency and complicates result correlation. The scanner can tell you port 8080 is open but not whether it's running Tomcat 9.0.45, Jenkins 2.277, or a custom application. This limitation is by design—implementing comprehensive service fingerprinting would require maintaining thousands of signatures and slow scan execution—but it means Naabu alone provides incomplete reconnaissance data.

**UDP scanning reliability** remains inherently limited by the protocol's stateless nature. Many firewalls silently drop UDP packets without sending ICMP unreachable messages, making it impossible to distinguish between open ports (no response), filtered ports (no response), and closed ports (ICMP unreachable). Naabu attempts UDP scanning when specified via `u:53` syntax, but accuracy rates fall significantly below TCP scanning. For critical UDP services like DNS, SNMP, or NTP, specialized tools or manual verification may be necessary.

**Version stability issues** emerged prominently in early 2025, when version 2.3.4 introduced a severe performance regression. Users scanning 300+ hosts observed CPU utilization dropping from 50-70% in version 2.3.3 to below 1% in version 2.3.4, with scan times increasing from minutes to hours. This regression particularly impacted Docker deployments with allocated CPU limits. The issue remained unresolved at the time of documentation, leading the community to recommend staying on version 2.3.3 until fixes were released. This instability highlights the importance of thorough testing when upgrading scanning tools in production environments.

The **Nmap CLI integration breaks** at scale when scanning large numbers of hosts with many open ports per host, requiring manual separation of the Naabu discovery phase and Nmap enumeration phase. Additionally, the integration doesn't produce standard XML output formats expected by many security orchestration platforms, instead relying on Nmap's native output flags passed through the `-nmap-cli` parameter. Organizations with strict reporting requirements may need to develop custom parsing logic.

**Rate limiting and accuracy tradeoffs** require careful tuning based on the target environment. The documented optimal setting of 7000 packets per second works well on VPS instances with dedicated network interfaces and good connectivity, but this same setting on residential internet connections or shared hosting environments triggers packet loss, overwhelming routers, and degraded accuracy. Conversely, the 1000 pps default setting underutilizes high-bandwidth cloud environments, leaving 80% of scanning capacity unused. No universal configuration exists—effective deployment requires measuring packet loss rates and adjusting `-rate`, `-timeout`, and `-retries` parameters iteratively.

## Novel insights from architecture and community adoption patterns

Examining Naabu's design reveals a broader evolution in security tooling philosophy. Traditional scanners like Nmap emerged in an era when comprehensive single-tool solutions were optimal—compute was expensive, automation was rare, and manual operation dominated workflows. Nmap's feature richness reflects this context: OS fingerprinting, service detection, NSE scripting, output formatting, timing controls, and scan type variety all integrated into one binary. This approach maximizes capability but increases complexity, creating a steep learning curve and slow execution when most features remain unused.

ProjectDiscovery's tools invert this model, embracing the microservices pattern in security reconnaissance. Each tool performs focused functionality with minimal overlap: Subfinder discovers assets, Naabu scans ports, httpx probes web services, Nuclei detects vulnerabilities. This decomposition enables **horizontal scaling**—multiple Naabu instances can scan different IP ranges in parallel, with results aggregated downstream. It also permits **specialized optimization**—Naabu optimizes specifically for port scanning throughput without the complexity of maintaining service signatures or scripting engines.

The **automatic IP deduplication algorithm** represents a specific insight about modern infrastructure. Cloud computing, CDN adoption, and containerization mean many organizations now route dozens or hundreds of domains through shared infrastructure. Traditional scanning tools, designed when each server had unique IPs, scan inefficiently in this environment. Naabu's hash-based IP tracking and automatic deduplication directly addresses this architectural shift, providing 5-10x speedups on typical bug bounty scopes compared to naive sequential subdomain scanning. This feature alone justifies Naabu adoption for web application testing workflows.

The **metrics endpoint** (localhost:63636) during scan execution demonstrates forward-thinking observability design. Modern security operations require telemetry about tool execution—how long scans take, how many ports are checked, what error rates occur. Exposing JSON metrics via HTTP endpoint enables integration with monitoring stacks (Prometheus, Grafana, Datadog), alerting on scan failures, and tracking reconnaissance efficiency over time. Few competing tools provide this level of operational visibility.

Community usage patterns reveal interesting adoption characteristics. The **bug bounty community standardized** on the Subfinder→Naabu→httpx→Nuclei pipeline almost universally, with variations occurring primarily in specific tool flags rather than tool selection. This standardization emerged organically through effectiveness rather than through official mandates, suggesting ProjectDiscovery successfully identified and filled genuine workflow gaps. Conversely, **penetration testing firms** show more fragmented adoption, often using Naabu for initial scans but maintaining Nmap for most work due to client reporting expectations, enterprise security team familiarity with Nmap output formats, and compliance requirements referencing Nmap specifically.

The **version stability regression** in 2.3.4 illustrates the challenge of maintaining performance in concurrent Go applications. The symptoms—CPU utilization dropping below 1% while scans continue running—suggest goroutine starvation, deadlock, or blocking on I/O without proper async handling. This type of regression is difficult to catch in unit tests but immediately apparent in production workloads, highlighting the importance of performance benchmarking in continuous integration pipelines and the value of community feedback channels for identifying real-world issues.

## Synthesis: choosing the right scanner for the reconnaissance context

Naabu's position in the port scanning landscape defies simple ranking because effectiveness depends fundamentally on operational context. For **bug bounty reconnaissance at scale**, where speed matters more than comprehensive enumeration and domain-based target lists are standard, Naabu represents the optimal choice. The IP deduplication feature, CDN awareness, and ProjectDiscovery tool integration deliver measurable efficiency gains that translate directly to finding vulnerabilities faster than competitors.

For **traditional penetration testing**, Nmap remains the industry standard due to feature completeness, extensive documentation, client expectations, and regulatory familiarity. However, integrating Naabu for the initial discovery phase—using it to rapidly identify the attack surface before detailed Nmap enumeration—combines the strengths of both approaches. This hybrid methodology completes reconnaissance phases 60-70% faster than Nmap-only workflows while maintaining equivalent coverage.

For **internet-scale research** requiring massive IP range scanning, Masscan and Zmap remain unmatched. Their ability to scan millions of IPs within minutes cannot be replicated by general-purpose tools. However, neither handles domain-based target lists gracefully, both require significant expertise to configure correctly, and neither integrates cleanly with modern vulnerability scanning workflows. Researchers use Masscan/Zmap for their specific strengths while recognizing they solve different problems than Naabu.

For **CTF and time-constrained scenarios**, RustScan's raw speed advantage becomes decisive. When racing to compromise systems under artificial time pressure, the difference between 8-second and 60-second full port scans matters significantly. However, RustScan's heavy dependency on Nmap for service detection and limited feature set make it less suitable for production security operations where reliability and integration capabilities outweigh marginal speed gains.

The fundamental insight is that **modern reconnaissance demands tool chains rather than single tools**. The question shifts from "Which scanner is best?" to "Which combination of scanners optimizes my specific workflow?" For most security practitioners, the answer involves Naabu for rapid port discovery when working with domain lists or web applications, Nmap for detailed enumeration and service detection, and potentially Masscan when scanning large IP ranges becomes necessary. Understanding each tool's architectural decisions, performance characteristics, and integration capabilities enables informed selection rather than dogmatic adherence to any single solution.

Naabu succeeds not by being the fastest, most feature-rich, or most comprehensive port scanner, but by being specifically optimized for the reconnaissance workflows that dominate modern security testing—particularly bug bounty hunting and cloud-native application security. Its architectural decisions around IP deduplication, CDN awareness, and seamless pipeline integration directly address pain points in these workflows that traditional scanners weren't designed to solve. This focused optimization, combined with active development, strong community support, and integration within a proven tool ecosystem, establishes Naabu as a essential component of contemporary security reconnaissance, even as complementary tools remain necessary for comprehensive security assessment.