# ProRT-IP v0.4.0 Development Plan: 6 Sprints to Release

**Created:** 2025-10-15
**Status:** Approved and Ready for Execution
**Total Duration:** 18-20 days (~3-4 weeks)
**Current State:** Phase 4 COMPLETE (v0.3.8, 933 tests, 61.92% coverage)
**Target:** v0.4.0 production release with competitive feature parity

---

## Executive Summary

Comprehensive plan for completing v0.4.0 release with complete PCAPNG/SQLite features, fragmentation/evasion, IPv6 support, error handling, and documentation. Based on analysis of all project documentation (root, docs/, ref-docs/, /tmp/ProRT-IP/).

**Sprint Order:** Sprint 4.18.1 (SQLite) → Sprint 4.18.4 (PCAPNG completion) → Sprint 4.20 (Fragmentation) → Sprint 4.21 (IPv6) → Sprint 4.22 (Error Handling) → Sprint 4.23 (Documentation/Release)

**Rationale for Order:**
1. **SQLite first** - Independent feature, no blockers, immediate value
2. **PCAPNG completion** - Completes Sprint 4.18.3 deferred work, scheduler refactor already done
3. **Fragmentation** - Competitive gap closure, stealth toolkit completion
4. **IPv6** - Future-proofing, enterprise requirement
5. **Error Handling** - Production hardening before release
6. **Documentation** - Final polish and release preparation

---

## Sprint 4.18.1: SQLite Query Interface & Export (~11 hours, MEDIUM priority)

**Why First:** Independent of PCAPNG scheduler refactor, provides immediate value, no blockers

### Objectives
- Add database indexes for 100x query performance improvement
- Implement query interface module with common query methods
- Add CLI `query` subcommand for SQL queries
- Create export utilities (CSV, JSON, XML formats)
- Comprehensive testing and documentation

### Tasks (11 hours total)

#### TASK 1: Database Indexes (1 hour)
**Goal:** Create 3 indexes in SQLite schema for query optimization

**Actions:**
- Update `crates/prtip-core/src/storage/sqlite.rs`
- Add indexes in `init_database()` or create migration function:
  - `idx_port_state ON scan_results(port, state)` - for "find all hosts with port X" queries
  - `idx_scan_target ON scan_results(scan_id, target_ip)` - for "find all open ports on host X" queries
  - `idx_service ON scan_results(service_name)` - for "list all services by name" queries
- Non-breaking migration (use `CREATE INDEX IF NOT EXISTS`)

**Testing:**
- Unit test: Verify indexes exist (query sqlite_master table)
- Unit test: Insert 1,000 records, query with index (<10ms)
- Unit test: Compare query performance with/without index (expect 100x+ speedup)

**Files Modified:**
- `crates/prtip-core/src/storage/sqlite.rs` (~30 lines added)

**Expected Performance Impact:**
| Query Type | Without Index | With Index | Speedup |
|------------|---------------|------------|---------|
| WHERE port=80 | 520ms | 5ms | 104x |
| WHERE service_name='HTTP' | 480ms | 8ms | 60x |
| WHERE scan_id=1 AND target_ip='10.0.0.1' | 450ms | 3ms | 150x |

---

#### TASK 2: Query Interface Module (3 hours)
**Goal:** Create query interface module with common query methods and raw SQL support

**Actions:**
- Create `crates/prtip-core/src/storage/scan_query.rs` (NEW file)
- Implement `ScanQuery` struct with connection pool
- Implement common query methods (3+):
  - `find_hosts_with_port(port: u16) -> Vec<ScanResult>`
  - `list_services_by_name(pattern: &str) -> Vec<ScanResult>` (supports LIKE wildcard)
  - `find_open_ports(target: IpAddr) -> Vec<u16>`
- Implement `execute_sql(sql: &str) -> Vec<ScanResult>` for raw SQL with parameter binding
- Use sqlx for async queries with parameter binding (SQL injection prevention)
- Return `Result<Vec<ScanResult>, sqlx::Error>` for all methods

**Code Skeleton:**
```rust
use sqlx::{SqlitePool, Row};
use std::net::IpAddr;
use std::path::Path;

pub struct ScanQuery {
    pool: SqlitePool,
}

#[derive(Debug, Clone)]
pub struct ScanResult {
    pub scan_id: i64,
    pub target_ip: IpAddr,
    pub port: u16,
    pub state: String,
    pub service_name: Option<String>,
    pub banner: Option<String>,
}

impl ScanQuery {
    pub async fn new(db_path: &Path) -> Result<Self, sqlx::Error> {
        let pool = SqlitePool::connect(&format!("sqlite:{}", db_path.display())).await?;
        Ok(Self { pool })
    }

    pub async fn find_hosts_with_port(&self, port: u16) -> Result<Vec<ScanResult>, sqlx::Error> {
        let results = sqlx::query(
            "SELECT scan_id, target_ip, port, state, service_name, banner
             FROM scan_results
             WHERE port = ? AND state = 'open'"
        )
        .bind(port)
        .fetch_all(&self.pool)
        .await?;

        // Map rows to ScanResult structs
        // ...
    }

    // ... other methods
}
```

**Testing:**
- Unit test: `find_hosts_with_port(80)` returns correct results
- Unit test: `list_services_by_name("HTTP")` with wildcard matching
- Unit test: `execute_sql()` with parameter binding
- Unit test: Invalid SQL returns error (not panic)
- Unit test: SQL injection prevention (attempt injection, verify safe handling)

**Files Modified:**
- `crates/prtip-core/src/storage/scan_query.rs` (NEW, ~200 lines)
- `crates/prtip-core/src/storage/mod.rs` (+1 line: `pub mod scan_query;`)

---

#### TASK 3: CLI Query Subcommand (2 hours)
**Goal:** Add `query` subcommand to CLI for executing SQL queries

**Actions:**
- Update `crates/prtip-cli/src/args.rs`:
  - Add `Commands::Query(QueryArgs)` variant
  - Create `QueryArgs` struct with fields:
    - `db: PathBuf` - path to SQLite database
    - `sql: String` - SQL query to execute
    - `format: String` - output format (table, json, csv)
- Update `crates/prtip-cli/src/main.rs`:
  - Add query command handler
  - Create ScanQuery instance from db path
  - Execute SQL query
  - Format results based on `--format` flag (table, JSON, CSV)
  - Handle errors gracefully (database not found, invalid SQL, etc.)

**Code Skeleton:**
```rust
// In args.rs
#[derive(Subcommand)]
pub enum Commands {
    Scan(ScanArgs),
    Query(QueryArgs),
}

#[derive(Args)]
pub struct QueryArgs {
    #[arg(long, short)]
    /// Path to SQLite database
    pub db: PathBuf,

    #[arg(long, short)]
    /// SQL query to execute
    pub sql: String,

    #[arg(long, short, default_value = "table")]
    /// Output format: table, json, csv
    pub format: String,
}

// In main.rs
Commands::Query(args) => {
    let query = ScanQuery::new(&args.db).await?;
    let results = query.execute_sql(&args.sql).await?;

    match args.format.as_str() {
        "json" => println!("{}", serde_json::to_string_pretty(&results)?),
        "csv" => { /* CSV formatting */ },
        "table" => { /* Table formatting */ },
        _ => eprintln!("Unknown format: {}", args.format),
    }
}
```

**Testing:**
- Integration test: Execute `prtip query --db test.db --sql "SELECT * FROM scan_results LIMIT 10"`
- Integration test: Test all output formats (table, JSON, CSV)
- Integration test: Handle missing database file gracefully
- Integration test: Handle invalid SQL gracefully

**Files Modified:**
- `crates/prtip-cli/src/args.rs` (~40 lines)
- `crates/prtip-cli/src/main.rs` (~60 lines)

**Usage Examples:**
```bash
# Query all open ports on a specific host
prtip query --db scan.db --sql "SELECT * FROM scan_results WHERE target_ip='192.168.1.1' AND state='open'"

# List all HTTP services
prtip query --db scan.db --sql "SELECT * FROM scan_results WHERE service_name LIKE '%HTTP%'" --format json

# Get scan summary
prtip query --db scan.db --sql "SELECT state, COUNT(*) as count FROM scan_results GROUP BY state"
```

---

#### TASK 4: Export Utilities (3 hours)
**Goal:** Create export utilities to convert SQLite database to CSV/JSON/XML formats

**Actions:**
- Create `crates/prtip-cli/src/export.rs` (NEW file)
- Add `Commands::Export(ExportArgs)` to args.rs
- Implement streaming export (constant memory usage for large datasets):
  - CSV formatter: Use `csv` crate with streaming writer
  - JSON formatter: Stream array of objects (not single JSON blob)
  - XML formatter: Reuse existing XML formatter from output module
- Add `--filter` option for selective export (SQL WHERE clause)
- Add `--output` option for output file path
- Handle large datasets efficiently (stream results, don't load all into memory)

**Code Skeleton:**
```rust
// In args.rs
#[derive(Args)]
pub struct ExportArgs {
    #[arg(long, short)]
    /// Path to SQLite database
    pub db: PathBuf,

    #[arg(long, short)]
    /// Export format: csv, json, xml
    pub format: String,

    #[arg(long, short)]
    /// Output file path
    pub output: PathBuf,

    #[arg(long)]
    /// Filter results (SQL WHERE clause)
    pub filter: Option<String>,
}

// In export.rs
pub async fn export_csv(query: &ScanQuery, output: &Path, filter: Option<&str>) -> Result<()> {
    let mut writer = csv::Writer::from_path(output)?;

    // Write CSV headers
    writer.write_record(&["scan_id", "target_ip", "port", "state", "service_name", "banner"])?;

    // Stream results (constant memory)
    let sql = if let Some(filter_clause) = filter {
        format!("SELECT * FROM scan_results WHERE {}", filter_clause)
    } else {
        "SELECT * FROM scan_results".to_string()
    };

    let results = query.execute_sql(&sql).await?;
    for result in results {
        writer.write_record(&[
            result.scan_id.to_string(),
            result.target_ip.to_string(),
            result.port.to_string(),
            result.state,
            result.service_name.unwrap_or_default(),
            result.banner.unwrap_or_default(),
        ])?;
    }

    writer.flush()?;
    Ok(())
}
```

**Testing:**
- Unit test: Export 1,000 records to CSV, verify file size and content
- Unit test: Export with filter (only open ports), verify correct subset
- Unit test: Export to JSON, verify valid JSON format
- Unit test: Export to XML, verify valid XML format
- Unit test: Handle write errors (read-only filesystem, disk full)

**Files Modified:**
- `crates/prtip-cli/src/export.rs` (NEW, ~300 lines)
- `crates/prtip-cli/src/args.rs` (~30 lines for ExportArgs)
- `crates/prtip-cli/src/main.rs` (~40 lines for export handler)
- `crates/prtip-cli/Cargo.toml` (add `csv = "1.3"` dependency if not present)

**Usage Examples:**
```bash
# Export entire database to CSV
prtip export --db scan.db --format csv --output results.csv

# Export only open ports to JSON
prtip export --db scan.db --format json --output open_ports.json --filter "state='open'"

# Export HTTP services to XML
prtip export --db scan.db --format xml --output http_services.xml --filter "service_name LIKE '%HTTP%'"
```

---

#### TASK 5: Integration Tests (1 hour)
**Goal:** Comprehensive integration tests for query interface and export utilities

**Actions:**
- Create `tests/integration/sqlite_query.rs` (NEW file)
- Test query performance on 100K-result database
- Test export to all formats with filtering
- Test SQL injection prevention (parameter binding)
- Test error handling (missing database, invalid SQL, write errors)

**Test Cases:**
```rust
#[tokio::test]
async fn test_query_performance_large_dataset() {
    // Create database with 100K records
    // Execute query with index
    // Assert query time < 100ms
}

#[tokio::test]
async fn test_export_csv_with_filter() {
    // Create database with mixed results
    // Export with filter (only open ports)
    // Verify CSV contains only filtered results
}

#[tokio::test]
async fn test_sql_injection_prevention() {
    // Attempt SQL injection in query
    // Verify safe handling (parameter binding prevents injection)
}

#[tokio::test]
async fn test_export_json_streaming() {
    // Export 10K records to JSON
    // Verify valid JSON format
    // Verify memory usage stays constant (streaming)
}
```

**Files Modified:**
- `tests/integration/sqlite_query.rs` (NEW, ~150 lines)

---

#### TASK 6: Documentation (1 hour)
**Goal:** Document SQLite query interface and export utilities

**Actions:**
- Update `README.md`:
  - Add "Database Queries" section (~50 lines)
  - Add examples for `prtip query` and `prtip export` commands
  - Show common use cases
- Create `docs/SQLITE-QUERIES.md` (NEW, ~200 lines):
  - Overview of query interface
  - Common query patterns (find hosts with port, list services, etc.)
  - Export workflow examples
  - SQL injection prevention notes
  - Performance tips (use indexes, avoid SELECT *)
- Update `CHANGELOG.md`:
  - Add Sprint 4.18.1 entry (~40 lines)
  - List all new features: query interface, export utilities, indexes
- Update `CLAUDE.local.md`:
  - Update sprint tracking with Sprint 4.18.1 completion
  - Update test counts and metrics

**Files Modified:**
- `README.md` (~50 lines added)
- `docs/SQLITE-QUERIES.md` (NEW, ~200 lines)
- `CHANGELOG.md` (~40 lines)
- `CLAUDE.local.md` (~30 lines updates)

**Documentation Outline (SQLITE-QUERIES.md):**
```markdown
# SQLite Database Queries

## Overview
ProRT-IP stores scan results in SQLite database with query interface for analysis.

## Query Interface

### Common Queries
- Find all hosts with port 80 open
- List all HTTP services
- Get all open ports on a specific host
- Count results by state

### Raw SQL Queries
- Using prtip query subcommand
- Parameter binding for safety
- SQL injection prevention

## Export Utilities

### Export to CSV
- Full database export
- Filtered export (only open ports)

### Export to JSON
- Streaming export for large datasets
- Integration with SIEM tools

### Export to XML
- Nmap-compatible XML format

## Performance Tips
- Use indexes for faster queries
- Avoid SELECT * on large databases
- Filter early in WHERE clause
```

---

### Sprint 4.18.1 Success Criteria

- ✅ 3 indexes created on scan_results table
- ✅ Query performance <10ms on 100K records
- ✅ Query interface with 3+ common methods + raw SQL
- ✅ CLI `prtip query --db scan.db --sql "..."`
- ✅ Export to CSV/JSON/XML with streaming
- ✅ 10+ new tests passing
- ✅ Zero regressions (933/933 existing tests still passing)
- ✅ Comprehensive documentation (SQLITE-QUERIES.md)

### Sprint 4.18.1 Deliverables

**Code:**
- Query interface module (~200 lines)
- Export utility module (~300 lines)
- CLI integration (~130 lines)
- Integration tests (~150 lines)
- **Total:** ~780 lines

**Documentation:**
- README.md updates (~50 lines)
- SQLITE-QUERIES.md guide (~200 lines)
- CHANGELOG.md entry (~40 lines)
- CLAUDE.local.md updates (~30 lines)
- **Total:** ~320 lines

**Expected Test Count:** 933 → 943 (+10 tests)

---

## Sprint 4.18.4: Complete PCAPNG Integration (~4-6 hours, HIGH priority)

**Why Second:** Completes Sprint 4.18.3 deferred work, scheduler refactor already done

### Objectives
- Integrate PCAPNG capture into TCP Connect, SYN, and Stealth scanners
- Wire --packet-capture flag to all scan types
- Complete integration tests for all scanners
- Create comprehensive OUTPUT-FORMATS.md documentation

### Current State (from Sprint 4.18.3)
- ✅ Scheduler multi-scan-type support (COMPLETE)
- ✅ CLI --packet-capture flag (COMPLETE)
- ✅ UDP scanner PCAPNG (COMPLETE)
- ⏸️ TCP/SYN/Stealth scanners (DEFERRED to this sprint)

### Context from Previous Work
Sprint 4.18 Phase 1-2 delivered:
- PCAPNG writer module (369 lines, thread-safe, Wireshark-compatible)
- UDP scanner integration working end-to-end
- 8 unit tests + 2 integration tests (4 ignored due to CAP_NET_RAW)

Sprint 4.18.3 delivered:
- Scheduler refactor for multi-scan-type routing
- CLI --packet-capture flag fully wired
- UDP PCAPNG capture working from CLI

### Tasks (4-6 hours total)

#### TASK 1: TCP Connect Scanner PCAPNG (1 hour)
**Goal:** Add PCAPNG capture to TCP Connect scanner

**Challenge:** OS-level `connect()` syscall hides packets from application layer

**Actions:**
- Update `crates/prtip-scanner/src/tcp_scanner.rs`
- Add optional `pcapng_writer` parameter to scan methods
- **Option A:** Capture via raw sockets if supported
  - Requires sending SYN packet, capturing SYN-ACK, then completing handshake
  - More complex but provides full packet visibility
- **Option B:** Document limitation
  - TCP Connect scan cannot capture packets (OS-level limitation)
  - Recommend using SYN scan (-sS) for TCP packet capture
  - Add warning message when --packet-capture used with -sT

**Recommended Approach:** Option B (document limitation)
- OS-level connect() is designed to hide implementation details
- Raw socket approach would essentially be SYN scan, not connect scan
- Clear documentation is better than complex workaround

**Code Changes:**
```rust
// In tcp_scanner.rs
impl TcpConnectScanner {
    pub async fn scan_ports_with_pcapng(
        &self,
        target: IpAddr,
        ports: Vec<u16>,
        pcapng_writer: Option<Arc<Mutex<PcapngWriter>>>,
    ) -> Vec<ScanResult> {
        if pcapng_writer.is_some() {
            warn!("TCP Connect scan (-sT) cannot capture packets (OS limitation). Use SYN scan (-sS) for packet capture.");
        }

        // Regular TCP connect scan (no packet capture)
        self.scan_ports(target, ports).await
    }
}
```

**Testing:**
- Unit test: Verify warning message when PCAPNG writer provided
- Integration test: TCP Connect scan with --packet-capture shows warning
- Documentation: Update OUTPUT-FORMATS.md with limitation note

**Files Modified:**
- `crates/prtip-scanner/src/tcp_scanner.rs` (~20 lines for warning)
- `docs/OUTPUT-FORMATS.md` (~50 lines for limitation section)

---

#### TASK 2: SYN Scanner PCAPNG (0.5 hour)
**Goal:** Add PCAPNG capture to SYN scanner

**Actions:**
- Update `crates/prtip-scanner/src/syn_scanner.rs`
- Follow UDP scanner pattern from Sprint 4.18 Phase 1-2
- Add `pcapng_writer: Option<Arc<Mutex<PcapngWriter>>>` parameter
- Capture SYN probe packets (Direction::Sent)
- Capture SYN-ACK/RST responses (Direction::Received)
- Handle errors gracefully (log warning, continue scan)

**Code Pattern (proven from UDP scanner):**
```rust
// In syn_scanner.rs
if let Some(ref writer) = pcapng_writer {
    if let Err(e) = writer.lock().unwrap().write_packet(
        &syn_packet,
        SystemTime::now(),
        Direction::Sent
    ) {
        eprintln!("[WARN] Failed to write SYN packet to capture: {}", e);
    }
}

// Send SYN packet
send_packet(&syn_packet)?;

// ... wait for response

// Capture response
if let Some(ref writer) = pcapng_writer {
    if let Err(e) = writer.lock().unwrap().write_packet(
        &response_packet,
        SystemTime::now(),
        Direction::Received
    ) {
        eprintln!("[WARN] Failed to write response to capture: {}", e);
    }
}
```

**Testing:**
- Unit test: SYN scanner with PCAPNG captures SYN packets
- Unit test: SYN scanner with PCAPNG captures SYN-ACK/RST responses
- Integration test: Full SYN scan with --packet-capture creates valid PCAPNG

**Files Modified:**
- `crates/prtip-scanner/src/syn_scanner.rs` (~25 lines)

---

#### TASK 3: Stealth Scanner PCAPNG (0.5 hour)
**Goal:** Add PCAPNG capture to Stealth scanner (FIN/NULL/Xmas/ACK)

**Actions:**
- Update `crates/prtip-scanner/src/stealth_scanner.rs`
- Add PCAPNG capture for all 4 stealth scan types:
  - FIN scan (-sF): Capture FIN packets + responses
  - NULL scan (-sN): Capture NULL packets + responses
  - Xmas scan (-sX): Capture FIN+PSH+URG packets + responses
  - ACK scan (-sA): Capture ACK packets + RST responses
- Follow same pattern as SYN scanner
- Capture probes (Direction::Sent) and responses (Direction::Received)

**Code Pattern:**
```rust
// In stealth_scanner.rs
pub async fn scan_port_with_pcapng(
    &mut self,
    target: IpAddr,
    port: u16,
    scan_type: StealthType, // FIN, NULL, Xmas, ACK
    pcapng_writer: Option<Arc<Mutex<PcapngWriter>>>,
) -> ScanResult {
    // Build stealth packet based on scan_type
    let packet = build_stealth_packet(target, port, scan_type)?;

    // Capture probe packet
    if let Some(ref writer) = pcapng_writer {
        writer.lock().unwrap().write_packet(&packet, SystemTime::now(), Direction::Sent)?;
    }

    // Send packet and receive response
    // ... (existing logic)

    // Capture response
    if let Some(ref writer) = pcapng_writer {
        writer.lock().unwrap().write_packet(&response, SystemTime::now(), Direction::Received)?;
    }

    // ... (existing result logic)
}
```

**Testing:**
- Unit test: FIN scan with PCAPNG captures FIN packets
- Unit test: NULL scan with PCAPNG captures NULL packets
- Unit test: Xmas scan with PCAPNG captures FIN+PSH+URG packets
- Unit test: ACK scan with PCAPNG captures ACK packets
- Integration test: All stealth scans with --packet-capture create valid PCAPNG

**Files Modified:**
- `crates/prtip-scanner/src/stealth_scanner.rs` (~30 lines)

---

#### TASK 4: Integration Tests (1 hour)
**Goal:** Comprehensive integration tests for all scanner PCAPNG capture

**Actions:**
- Update `crates/prtip-scanner/tests/integration_pcapng.rs` (from Sprint 4.18 Phase 1-2)
- Add tests for TCP Connect (verify warning message)
- Add tests for SYN scanner PCAPNG
- Add tests for all Stealth scanner types (FIN/NULL/Xmas/ACK)
- Mark CAP_NET_RAW-dependent tests as #[ignore]
- Verify PCAPNG files open in Wireshark (manual test)

**Test Cases:**
```rust
#[test]
fn test_tcp_connect_pcapng_warning() {
    // Run TCP Connect scan with --packet-capture
    // Verify warning message appears
    // Verify scan completes successfully
}

#[test]
#[ignore] // Requires CAP_NET_RAW
fn test_syn_scan_pcapng_capture() {
    // Run SYN scan with PCAPNG capture
    // Verify PCAPNG file created
    // Verify file contains SYN packets (Direction::Sent)
    // Verify file contains SYN-ACK/RST packets (Direction::Received)
    // Verify packet count matches scan activity
}

#[test]
#[ignore] // Requires CAP_NET_RAW
fn test_stealth_fin_scan_pcapng() {
    // Run FIN scan with PCAPNG capture
    // Verify PCAPNG file contains FIN packets
}

#[test]
#[ignore] // Requires CAP_NET_RAW
fn test_stealth_null_scan_pcapng() {
    // Run NULL scan with PCAPNG capture
    // Verify PCAPNG file contains NULL packets
}

#[test]
#[ignore] // Requires CAP_NET_RAW
fn test_stealth_xmas_scan_pcapng() {
    // Run Xmas scan with PCAPNG capture
    // Verify PCAPNG file contains FIN+PSH+URG packets
}

#[test]
#[ignore] // Requires CAP_NET_RAW
fn test_stealth_ack_scan_pcapng() {
    // Run ACK scan with PCAPNG capture
    // Verify PCAPNG file contains ACK packets
}

#[test]
#[ignore] // Manual test: requires Wireshark
fn test_all_pcapng_open_in_wireshark() {
    // Generate PCAPNG files for all scan types
    // Manual step: Open each in Wireshark
    // Verify: No errors, packets visible, metadata correct
}
```

**Files Modified:**
- `crates/prtip-scanner/tests/integration_pcapng.rs` (+100 lines, 6 new tests)

---

#### TASK 5: Documentation OUTPUT-FORMATS.md (1-2 hours)
**Goal:** Create comprehensive OUTPUT-FORMATS.md documentation covering all 6 output formats

**Actions:**
- Create `docs/OUTPUT-FORMATS.md` (NEW, ~400 lines)
- Document all 6 output formats:
  1. **Text** (default, human-readable)
  2. **JSON** (-oJ, structured data)
  3. **XML** (-oX, nmap-compatible)
  4. **Greppable** (-oG, masscan-compatible)
  5. **SQLite** (--db, queryable database)
  6. **PCAPNG** (--packet-capture, Wireshark-compatible)
- Include examples for each format
- Document use cases and tool integration
- Provide Wireshark workflow for PCAPNG analysis
- Document limitations (TCP Connect cannot capture packets)

**Document Outline:**
```markdown
# ProRT-IP Output Formats

## Overview
ProRT-IP supports 6 output formats for different use cases.

## 1. Text Output (Default)
- Human-readable table format
- Colorized output (optional)
- Usage: `prtip -sS -p 80,443 target.com`

## 2. JSON Output (-oJ)
- Structured JSON format
- Usage: `prtip -sS -p 80,443 target.com -oJ output.json`
- Integration with jq, Python scripts, SIEM tools

## 3. XML Output (-oX)
- Nmap-compatible XML format
- Usage: `prtip -sS -p 80,443 target.com -oX output.xml`
- Integration with Metasploit, vulnerability scanners

## 4. Greppable Output (-oG)
- Masscan-compatible line-based format
- Usage: `prtip -sS -p 80,443 target.com -oG output.gnmap`
- Easy parsing with grep, awk, sed

## 5. SQLite Database (--db)
- Queryable database storage
- Usage: `prtip -sS -p 80,443 target.com --db scan.db`
- Query: `prtip query --db scan.db --sql "SELECT * FROM scan_results"`
- Export: `prtip export --db scan.db --format csv --output results.csv`

## 6. PCAPNG Packet Capture (--packet-capture)
- Wireshark-compatible packet capture
- Usage: `prtip -sS -p 80,443 target.com --packet-capture scan.pcapng`
- Wireshark analysis workflow
- Forensic investigation

### Supported Scan Types for PCAPNG
- ✅ UDP (-sU): Full packet capture
- ✅ SYN (-sS): SYN/SYN-ACK/RST packets
- ✅ Stealth (-sF/-sN/-sX/-sA): Probe + response packets
- ⚠️ TCP Connect (-sT): Not supported (OS limitation, use -sS instead)

### PCAPNG Features
- Thread-safe concurrent writes
- Automatic file rotation at 1GB
- Microsecond-precision timestamps
- Direction tracking (Sent/Received)
- Wireshark-compatible format (SHB, IDB, EPB blocks)

### Wireshark Analysis Workflow
1. Open PCAPNG file in Wireshark
2. Apply display filters: `tcp.flags.syn==1 and tcp.flags.ack==0`
3. Analyze packet timing (RTT, retransmissions)
4. Examine service banners in TCP streams
5. Export specific packets for further analysis

## Limitations
- **TCP Connect PCAPNG**: OS-level connect() hides packets, cannot capture. Use SYN scan (-sS) for TCP packet capture.
- **IPv6 UDP PCAPNG**: Not yet supported (deferred to Sprint 4.21)
- **Real-time Streaming**: PCAPNG files written to disk, not streamed to Wireshark live (Phase 5 feature)

## Use Cases

### Security Assessment
- **Text/JSON**: Quick scan results review
- **XML**: Integration with vulnerability scanners
- **PCAPNG**: Detailed packet analysis, IDS testing

### Forensic Investigation
- **PCAPNG**: Packet-level forensics
- **SQLite**: Temporal analysis, correlate multiple scans

### Automation & Integration
- **Greppable**: Shell script parsing
- **JSON**: Python/Ruby automation
- **SQLite**: Database-driven reporting

## Performance Considerations
- **PCAPNG**: ~5% overhead, buffered writes, thread-safe
- **SQLite**: Batch inserts (1K-10K/tx), indexes for fast queries
- **Text/JSON/XML**: Minimal overhead, streaming output
```

**Files Modified:**
- `docs/OUTPUT-FORMATS.md` (NEW, ~400 lines)

**Additional Documentation Updates:**
- `README.md`: Add PCAPNG examples (~50 lines)
- `CHANGELOG.md`: Add Sprint 4.18.4 entry (~40 lines)
- `CLAUDE.local.md`: Update sprint tracking (~30 lines)

---

### Sprint 4.18.4 Success Criteria

- ✅ TCP/SYN/Stealth scanners have PCAPNG integration
- ✅ --packet-capture flag works for all supported scan types
- ✅ TCP Connect limitation documented (recommend -sS)
- ✅ Integration tests for all scanners (6+ new tests, some #[ignore])
- ✅ OUTPUT-FORMATS.md complete and comprehensive
- ✅ Zero regressions (943/943 tests + new tests passing)
- ✅ PCAPNG files open in Wireshark without errors

### Sprint 4.18.4 Known Limitations (Document)

1. **TCP Connect Limitation:**
   - OS-level connect() syscall hides packets from application
   - Cannot capture TCP handshake in Connect scan mode
   - **Workaround:** Use SYN scan (-sS) for TCP packet capture

2. **IPv6 UDP Limitation:**
   - UDP scanner only supports IPv4 currently
   - IPv6 UDP PCAPNG capture deferred to Sprint 4.21

3. **Real-Time Streaming:**
   - PCAPNG files written to disk only
   - No live streaming to Wireshark (pipe mode)
   - **Future:** Phase 5 feature (real-time PCAPNG streaming)

### Sprint 4.18.4 Deliverables

**Code:**
- TCP Connect warning (~20 lines)
- SYN scanner PCAPNG (~25 lines)
- Stealth scanner PCAPNG (~30 lines)
- Integration tests (~100 lines)
- **Total:** ~175 lines

**Documentation:**
- OUTPUT-FORMATS.md (~400 lines)
- README.md updates (~50 lines)
- CHANGELOG.md entry (~40 lines)
- CLAUDE.local.md updates (~30 lines)
- **Total:** ~520 lines

**Expected Test Count:** 943 → 950 (+7 tests, 4-5 may be #[ignore])

---

## Sprint 4.20: Fragmentation & Evasion (~4-5 days, MEDIUM priority)

**Why Third:** Completes stealth toolkit, addresses competitive gap vs Nmap

### Objectives (from docs/19-PHASE4-ENHANCEMENTS.md)
- IP fragmentation techniques (-f, -ff, --mtu)
- Fragment reassembly evasion
- TTL manipulation
- IP options insertion
- Bad checksum generation (IDS evasion)

### Background
Fragmentation and evasion techniques enable:
- Firewall bypass (fragmented packets evade some firewalls)
- IDS evasion (split signatures across fragments)
- Network security testing (validate firewall rules)
- Competitive parity with Nmap's complete evasion toolkit

### Tasks (4-5 days total)

#### TASK 1: IP Fragmentation Implementation (2 days)
**Goal:** Implement IP fragmentation techniques for evasion

**Actions:**
- Create `crates/prtip-network/src/fragmentation.rs` (NEW, ~400 lines)
- Implement 3 fragmentation modes:
  - `-f` flag: 8-byte fragments (aggressive fragmentation)
  - `-ff` flag: 16-byte fragments (moderate fragmentation)
  - `--mtu` flag: Custom MTU size (user-specified)
- Fragment reassembly evasion techniques:
  - Overlapping fragments (confuse IDS)
  - Out-of-order fragments
  - Fragment timeout manipulation
- IPv4 fragmentation logic:
  - Fragment Offset field calculation
  - More Fragments (MF) flag setting
  - Fragment ID generation
  - Checksum recalculation per fragment

**Code Skeleton:**
```rust
pub struct Fragmenter {
    fragment_size: usize, // 8, 16, or custom MTU
    fragment_id: u16,
}

impl Fragmenter {
    pub fn new(mode: FragmentMode) -> Self {
        let fragment_size = match mode {
            FragmentMode::Aggressive => 8,  // -f
            FragmentMode::Moderate => 16,   // -ff
            FragmentMode::Custom(mtu) => mtu,
        };
        Self { fragment_size, fragment_id: 0 }
    }

    pub fn fragment_packet(&mut self, packet: &[u8]) -> Vec<Vec<u8>> {
        // Split packet into fragments
        // Set Fragment Offset, MF flag
        // Recalculate checksums
        // Return vector of fragment packets
    }

    pub fn fragment_with_evasion(&mut self, packet: &[u8], evasion: EvasionTechnique) -> Vec<Vec<u8>> {
        match evasion {
            EvasionTechnique::Overlapping => self.overlapping_fragments(packet),
            EvasionTechnique::OutOfOrder => self.shuffle_fragments(packet),
            EvasionTechnique::Timeout => self.delayed_fragments(packet),
        }
    }
}
```

**Testing:**
- Unit test: Fragment 100-byte packet with -f (8-byte fragments)
- Unit test: Fragment 100-byte packet with -ff (16-byte fragments)
- Unit test: Fragment with custom MTU (--mtu 20)
- Unit test: Verify Fragment Offset calculation
- Unit test: Verify MF flag set correctly (all fragments except last)
- Unit test: Overlapping fragment generation
- Integration test: Send fragmented SYN scan, verify target receives

**Files Modified:**
- `crates/prtip-network/src/fragmentation.rs` (NEW, ~400 lines)
- `crates/prtip-network/src/lib.rs` (+1 line: `pub mod fragmentation;`)

---

#### TASK 2: TTL and IP Options (1 day)
**Goal:** Implement TTL manipulation and IP options insertion

**Actions:**
- Create `crates/prtip-network/src/ip_options.rs` (NEW, ~250 lines)
- Implement TTL manipulation:
  - `--ttl <value>` flag: Set custom TTL (1-255)
  - Use cases: Traceroute-style scanning, firewall bypass
- Implement IP options insertion:
  - Loose Source Routing (LSR): Specify intermediate hops
  - Strict Source Routing (SSR): Force exact path
  - Record Route (RR): Record path taken
  - Timestamp (TS): Record timestamps at hops
- IPv4 Options header format:
  - Option Type (1 byte)
  - Option Length (1 byte)
  - Option Data (variable)

**Code Skeleton:**
```rust
pub enum IpOption {
    LooseSourceRoute(Vec<IpAddr>),
    StrictSourceRoute(Vec<IpAddr>),
    RecordRoute { max_hops: u8 },
    Timestamp { max_hops: u8 },
}

pub struct IpOptionsBuilder {
    options: Vec<IpOption>,
    ttl: Option<u8>,
}

impl IpOptionsBuilder {
    pub fn set_ttl(&mut self, ttl: u8) -> &mut Self {
        self.ttl = Some(ttl);
        self
    }

    pub fn add_option(&mut self, option: IpOption) -> &mut Self {
        self.options.push(option);
        self
    }

    pub fn build_header(&self, base_packet: &[u8]) -> Vec<u8> {
        // Insert IP options into packet header
        // Update IHL (Internet Header Length) field
        // Recalculate checksums
    }
}
```

**Testing:**
- Unit test: Set TTL to 64, verify IP header
- Unit test: Set TTL to 1 (single-hop), verify
- Unit test: Add Loose Source Route option, verify header format
- Unit test: Add Record Route option, verify header format
- Unit test: Combine TTL + IP options, verify correct header construction
- Integration test: Send packet with TTL=5, verify behavior

**Files Modified:**
- `crates/prtip-network/src/ip_options.rs` (NEW, ~250 lines)
- `crates/prtip-network/src/lib.rs` (+1 line: `pub mod ip_options;`)

---

#### TASK 3: Evasion Techniques (1 day)
**Goal:** Implement evasion techniques for IDS/firewall bypass

**Actions:**
- Create `crates/prtip-scanner/src/evasion.rs` (NEW, ~200 lines)
- Implement bad checksum generation:
  - `--badsum` flag: Generate incorrect checksums
  - Use case: Test IDS/firewall checksum validation
  - Some IDS skip packets with bad checksums (assumes corruption)
- Enhance decoy scanning (already implemented in Enhancement Cycle 8):
  - Refine decoy packet generation
  - Improve randomization patterns
  - Integration with fragmentation
- Add timing randomization for evasion:
  - Variable inter-packet delays
  - Avoid pattern detection

**Code Skeleton:**
```rust
pub struct EvasionConfig {
    pub bad_checksum: bool,
    pub decoys: Vec<IpAddr>,
    pub randomize_timing: bool,
}

pub fn apply_evasion(packet: &mut [u8], config: &EvasionConfig) {
    if config.bad_checksum {
        corrupt_checksum(packet);
    }

    if config.randomize_timing {
        // Add random delay before sending
        // Implemented in scanner layer
    }
}

fn corrupt_checksum(packet: &mut [u8]) {
    // Calculate correct checksum
    let correct_checksum = calculate_checksum(packet);

    // Generate incorrect checksum (flip random bit)
    let bad_checksum = correct_checksum ^ 0x0001;

    // Write bad checksum to packet
    write_checksum(packet, bad_checksum);
}
```

**Testing:**
- Unit test: Generate packet with --badsum, verify checksum is incorrect
- Unit test: Decoy packet generation (already tested in Cycle 8, enhance)
- Unit test: Timing randomization produces variable delays
- Integration test: Send scan with --badsum, verify IDS behavior (manual test)

**Files Modified:**
- `crates/prtip-scanner/src/evasion.rs` (NEW, ~200 lines)
- `crates/prtip-scanner/src/decoy_scanner.rs` (enhance existing, ~50 lines)
- `crates/prtip-scanner/src/lib.rs` (+1 line: `pub mod evasion;`)

---

#### TASK 4: CLI Integration & Testing (0.5-1 day)
**Goal:** Integrate fragmentation and evasion into CLI with comprehensive tests

**Actions:**
- Update `crates/prtip-cli/src/args.rs`:
  - Add `-f` flag (aggressive fragmentation)
  - Add `-ff` flag (moderate fragmentation)
  - Add `--mtu <size>` flag (custom MTU)
  - Add `--ttl <value>` flag (custom TTL)
  - Add `--ip-options <options>` flag (LSR, SSR, RR, TS)
  - Add `--badsum` flag (bad checksum generation)
- Update scanner integration to apply fragmentation/evasion
- Comprehensive unit tests (15+):
  - Test each fragmentation mode
  - Test TTL manipulation
  - Test IP options insertion
  - Test bad checksum generation
  - Test combinations (fragmentation + TTL + evasion)
- Integration tests for real-world scenarios
- Update documentation:
  - Create `docs/EVASION-TECHNIQUES.md` (~300 lines)
  - Update README.md with evasion examples
  - Update CHANGELOG.md

**CLI Flag Examples:**
```bash
# Aggressive fragmentation
prtip -sS -f -p 80,443 target.com

# Moderate fragmentation with custom TTL
prtip -sS -ff --ttl 64 -p 80,443 target.com

# Custom MTU with bad checksum
prtip -sS --mtu 20 --badsum -p 80 target.com

# Combine fragmentation + decoys + TTL
prtip -sS -f --ttl 128 -D RND:10 -p 1-1000 target.com
```

**Testing:**
- Unit test: Parse -f flag correctly
- Unit test: Parse -ff flag correctly
- Unit test: Parse --mtu with validation (8-1500 bytes)
- Unit test: Parse --ttl with validation (1-255)
- Unit test: Parse --badsum flag
- Integration test: Fragmented scan completes successfully
- Integration test: TTL manipulation verified
- Integration test: Bad checksum packets generated

**Files Modified:**
- `crates/prtip-cli/src/args.rs` (~60 lines for flags)
- `crates/prtip-scanner/src/scanner.rs` (~40 lines integration)
- Unit tests (~200 lines)
- Integration tests (~100 lines)
- `docs/EVASION-TECHNIQUES.md` (NEW, ~300 lines)
- `README.md` (~50 lines examples)
- `CHANGELOG.md` (~40 lines)

**Documentation Outline (EVASION-TECHNIQUES.md):**
```markdown
# ProRT-IP Evasion Techniques

## Overview
Evasion techniques for firewall/IDS bypass and security testing.

## Fragmentation
- Aggressive (-f): 8-byte fragments
- Moderate (-ff): 16-byte fragments
- Custom MTU (--mtu): User-specified fragment size
- Use cases: Evade packet inspection, bypass firewalls

## TTL Manipulation
- Custom TTL (--ttl): Set Time-To-Live value
- Use cases: Traceroute-style scanning, hop-based evasion

## IP Options
- Loose Source Routing: Specify intermediate hops
- Strict Source Routing: Force exact path
- Record Route: Record path taken
- Timestamp: Timestamp at each hop

## Bad Checksum
- Generate invalid checksums (--badsum)
- Use case: Test IDS checksum validation
- Some IDS skip packets with bad checksums

## Decoy Scanning
- Already implemented (Enhancement Cycle 8)
- Combine with fragmentation for advanced evasion

## Ethical and Legal Considerations
- Use only on networks you own or have permission to test
- Evasion techniques for security testing, not malicious use
- Consult legal counsel before testing production systems
```

---

### Sprint 4.20 Success Criteria

- ✅ IP fragmentation working (-f, -ff, --mtu)
- ✅ TTL manipulation (--ttl)
- ✅ IP options insertion (LSR, SSR, RR, TS)
- ✅ Bad checksum generation (--badsum)
- ✅ 15+ new tests passing
- ✅ Comprehensive evasion documentation (EVASION-TECHNIQUES.md)
- ✅ Zero regressions (950/950 tests + new tests passing)

### Sprint 4.20 Deliverables

**Code:**
- Fragmentation module (~400 lines)
- IP options module (~250 lines)
- Evasion techniques (~200 lines)
- CLI integration (~100 lines)
- Tests (~300 lines)
- **Total:** ~1,250 lines

**Documentation:**
- EVASION-TECHNIQUES.md (~300 lines)
- README.md updates (~50 lines)
- CHANGELOG.md entry (~40 lines)
- CLAUDE.local.md updates (~30 lines)
- **Total:** ~420 lines

**Expected Test Count:** 950 → 965 (+15 tests)

### Sprint 4.20 ROI: 7.0/10
- **Strategic:** Completes Nmap parity for evasion techniques
- **User Impact:** Security professionals need fragmentation for firewall testing
- **Effort:** Medium (4-5 days)
- **Competitive:** Addresses gap identified in Phase 4 enhancements analysis

---

## Sprint 4.21: IPv6 Complete Implementation (~3-4 days, MEDIUM priority)

**Why Fourth:** Future-proofing, enterprise requirement, addresses competitive gap

### Objectives (from docs/01-ROADMAP.md + docs/19-PHASE4-ENHANCEMENTS.md)
- Full IPv6 address parsing and scanning
- ICMPv6 neighbor discovery
- Dual-stack scanning (IPv4 + IPv6 simultaneously)
- IPv6-specific features (extension headers, fragmentation)

### Background
IPv6 support is critical for:
- **Enterprise deployments:** Many organizations dual-stack or IPv6-only
- **Government contracts:** IPv6 mandate for federal systems
- **Future-proofing:** IPv4 exhaustion drives IPv6 adoption
- **Competitive parity:** Nmap, RustScan, Naabu all support IPv6

### Tasks (3-4 days total)

#### TASK 1: IPv6 Packet Building (1.5 days)
**Goal:** Implement IPv6 packet construction infrastructure

**Actions:**
- Create `crates/prtip-network/src/ipv6.rs` (NEW, ~500 lines)
- Implement IPv6 header construction:
  - Version (4 bits, always 6)
  - Traffic Class (8 bits, QoS)
  - Flow Label (20 bits, flow identification)
  - Payload Length (16 bits)
  - Next Header (8 bits, protocol)
  - Hop Limit (8 bits, equivalent to IPv4 TTL)
  - Source/Destination Address (128 bits each)
- Implement IPv6 extension headers:
  - Hop-by-Hop Options Header
  - Routing Header (source routing)
  - Fragment Header (IPv6 fragmentation)
  - Destination Options Header
- Implement ICMPv6 packet building:
  - Neighbor Solicitation (NDP)
  - Neighbor Advertisement
  - Router Advertisement
  - Router Solicitation
- Implement TCP/UDP over IPv6:
  - Pseudo-header for checksum calculation
  - Upper-layer protocol integration

**Code Skeleton:**
```rust
pub struct Ipv6Packet {
    pub version: u8,  // Always 6
    pub traffic_class: u8,
    pub flow_label: u32,
    pub payload_length: u16,
    pub next_header: u8,
    pub hop_limit: u8,
    pub source: Ipv6Addr,
    pub destination: Ipv6Addr,
    pub extension_headers: Vec<ExtensionHeader>,
    pub payload: Vec<u8>,
}

pub enum ExtensionHeader {
    HopByHop { options: Vec<Ipv6Option> },
    Routing { addresses: Vec<Ipv6Addr> },
    Fragment { id: u32, offset: u16, more_fragments: bool },
    DestinationOptions { options: Vec<Ipv6Option> },
}

pub enum Icmpv6Type {
    NeighborSolicitation { target: Ipv6Addr },
    NeighborAdvertisement { target: Ipv6Addr, mac: MacAddr },
    RouterAdvertisement,
    RouterSolicitation,
}

impl Ipv6Packet {
    pub fn new(source: Ipv6Addr, destination: Ipv6Addr) -> Self {
        Self {
            version: 6,
            traffic_class: 0,
            flow_label: 0,
            payload_length: 0,
            next_header: 59, // No Next Header
            hop_limit: 64,
            source,
            destination,
            extension_headers: Vec::new(),
            payload: Vec::new(),
        }
    }

    pub fn add_extension_header(&mut self, header: ExtensionHeader) {
        self.extension_headers.push(header);
    }

    pub fn build(&self) -> Vec<u8> {
        // Serialize IPv6 header + extension headers + payload
    }
}
```

**Testing:**
- Unit test: Build basic IPv6 header, verify structure
- Unit test: Add Hop-by-Hop extension header, verify
- Unit test: Add Fragment extension header, verify offset calculation
- Unit test: Build ICMPv6 Neighbor Solicitation packet
- Unit test: Calculate pseudo-header checksum for TCP over IPv6
- Unit test: Build TCP SYN packet over IPv6

**Files Modified:**
- `crates/prtip-network/src/ipv6.rs` (NEW, ~500 lines)
- `crates/prtip-network/src/lib.rs` (+1 line: `pub mod ipv6;`)

---

#### TASK 2: IPv6 Scanning Logic (1 day)
**Goal:** Implement IPv6 scanning logic with ICMPv6 neighbor discovery

**Actions:**
- Create `crates/prtip-scanner/src/ipv6_scanner.rs` (NEW, ~350 lines)
- Implement IPv6 address parsing:
  - CIDR notation (2001:db8::/32)
  - IPv6 ranges (2001:db8::1-2001:db8::100)
  - Hostname resolution (AAAA records)
- Implement ICMPv6 neighbor discovery:
  - Send Neighbor Solicitation
  - Receive Neighbor Advertisement
  - Extract MAC address from NDP
- Implement IPv6 port scanning:
  - TCP SYN scan over IPv6
  - TCP Connect scan over IPv6
  - UDP scan over IPv6 (with ICMPv6 Port Unreachable)
- Handle IPv6-specific responses:
  - ICMPv6 Packet Too Big (MTU discovery)
  - ICMPv6 Parameter Problem
  - ICMPv6 Destination Unreachable

**Code Skeleton:**
```rust
pub struct Ipv6Scanner {
    config: ScanConfig,
    source_addr: Ipv6Addr,
}

impl Ipv6Scanner {
    pub async fn discover_neighbor(&self, target: Ipv6Addr) -> Result<MacAddr> {
        // Send ICMPv6 Neighbor Solicitation
        let ns_packet = build_neighbor_solicitation(self.source_addr, target);
        send_packet(&ns_packet)?;

        // Wait for Neighbor Advertisement
        let na_packet = receive_packet(timeout)?;

        // Extract MAC address
        parse_neighbor_advertisement(&na_packet)
    }

    pub async fn scan_port(&self, target: Ipv6Addr, port: u16) -> Result<PortState> {
        // Build TCP SYN packet over IPv6
        let syn_packet = build_ipv6_tcp_syn(self.source_addr, target, port);
        send_packet(&syn_packet)?;

        // Wait for SYN-ACK or RST
        let response = receive_packet(timeout)?;

        match parse_response(&response) {
            TcpFlags::SYN_ACK => Ok(PortState::Open),
            TcpFlags::RST => Ok(PortState::Closed),
            _ => Ok(PortState::Filtered),
        }
    }
}
```

**Testing:**
- Unit test: Parse IPv6 CIDR notation (2001:db8::/32)
- Unit test: Parse IPv6 range (2001:db8::1-100)
- Unit test: Build Neighbor Solicitation packet
- Unit test: Parse Neighbor Advertisement response
- Unit test: Build TCP SYN over IPv6
- Integration test: IPv6 scan against ::1 (localhost)
- Integration test: ICMPv6 neighbor discovery on local network

**Files Modified:**
- `crates/prtip-scanner/src/ipv6_scanner.rs` (NEW, ~350 lines)
- `crates/prtip-scanner/src/lib.rs` (+1 line: `pub mod ipv6_scanner;`)

---

#### TASK 3: Dual-Stack Support (0.5 day)
**Goal:** Implement simultaneous IPv4 + IPv6 scanning

**Actions:**
- Create `crates/prtip-scanner/src/dual_stack.rs` (NEW, ~200 lines)
- Implement address family detection:
  - Detect if target is IPv4, IPv6, or hostname
  - Resolve hostnames to both A and AAAA records
- Implement dual-stack scanning:
  - Scan IPv4 and IPv6 simultaneously (parallel)
  - Merge results from both address families
  - Handle targets with only IPv4, only IPv6, or both
- Add CLI flag `-6` or `--ipv6-only` for IPv6-only scans

**Code Skeleton:**
```rust
pub struct DualStackScanner {
    ipv4_scanner: Scanner,
    ipv6_scanner: Ipv6Scanner,
}

impl DualStackScanner {
    pub async fn scan_target(&self, target: &str) -> Result<Vec<ScanResult>> {
        // Resolve target to IPv4 and/or IPv6 addresses
        let (ipv4_addrs, ipv6_addrs) = resolve_dual_stack(target).await?;

        // Scan both address families in parallel
        let ipv4_results = self.ipv4_scanner.scan_targets(&ipv4_addrs);
        let ipv6_results = self.ipv6_scanner.scan_targets(&ipv6_addrs);

        let (v4, v6) = tokio::join!(ipv4_results, ipv6_results);

        // Merge results
        let mut results = v4?;
        results.extend(v6?);
        Ok(results)
    }
}
```

**Testing:**
- Unit test: Resolve hostname to A + AAAA records
- Unit test: Scan target with both IPv4 and IPv6
- Unit test: Scan IPv4-only target (no AAAA record)
- Unit test: Scan IPv6-only target (no A record)
- Integration test: Dual-stack scan of google.com (has both)
- Integration test: --ipv6-only flag forces IPv6

**Files Modified:**
- `crates/prtip-scanner/src/dual_stack.rs` (NEW, ~200 lines)
- `crates/prtip-scanner/src/lib.rs` (+1 line: `pub mod dual_stack;`)

---

#### TASK 4: CLI Integration & Testing (1 day)
**Goal:** Integrate IPv6 into CLI with comprehensive tests

**Actions:**
- Update `crates/prtip-cli/src/args.rs`:
  - Add `-6` or `--ipv6-only` flag (force IPv6)
  - Add `--ipv4-only` flag (force IPv4, for completeness)
  - Default: Dual-stack (both IPv4 and IPv6)
- Update scanner integration to support IPv6
- Comprehensive unit tests (20+):
  - Test IPv6 address parsing
  - Test ICMPv6 packet building
  - Test IPv6 TCP/UDP scanning
  - Test dual-stack resolution
  - Test all scan types over IPv6 (SYN, Connect, UDP)
- Integration tests for IPv6 scanning
- Update documentation:
  - Update README.md with IPv6 examples
  - Update ARCHITECTURE.md with IPv6 support
  - Update CHANGELOG.md

**CLI Flag Examples:**
```bash
# Dual-stack scan (default)
prtip -sS -p 80,443 google.com

# IPv6-only scan
prtip -6 -sS -p 80,443 ipv6.google.com

# IPv4-only scan
prtip --ipv4-only -sS -p 80,443 example.com

# IPv6 CIDR scan
prtip -6 -sS -p 80 2001:db8::/120

# IPv6 localhost scan
prtip -6 -sS -p 1-1000 ::1
```

**Testing:**
- Unit test: Parse -6 flag correctly
- Unit test: Parse --ipv4-only flag correctly
- Unit test: Default is dual-stack
- Unit test: IPv6 CIDR parsing (2001:db8::/32)
- Unit test: IPv6 range parsing (2001:db8::1-100)
- Integration test: IPv6 SYN scan against ::1
- Integration test: IPv6 Connect scan
- Integration test: IPv6 UDP scan with ICMPv6 responses
- Integration test: Dual-stack scan resolves both A and AAAA

**Files Modified:**
- `crates/prtip-cli/src/args.rs` (~40 lines for flags)
- `crates/prtip-scanner/src/scanner.rs` (~60 lines integration)
- Unit tests (~300 lines)
- Integration tests (~100 lines)
- `README.md` (~50 lines examples)
- `docs/00-ARCHITECTURE.md` (~80 lines IPv6 section)
- `CHANGELOG.md` (~40 lines)

---

### Sprint 4.21 Success Criteria

- ✅ Full IPv6 scanning support (SYN, Connect, UDP)
- ✅ ICMPv6 neighbor discovery working
- ✅ Dual-stack scanning (IPv4 + IPv6 simultaneously)
- ✅ IPv6 extension headers support
- ✅ 20+ new tests passing
- ✅ IPv6 documentation complete
- ✅ Zero regressions (965/965 tests + new tests passing)

### Sprint 4.21 Deliverables

**Code:**
- IPv6 packet building (~500 lines)
- IPv6 scanning logic (~350 lines)
- Dual-stack support (~200 lines)
- CLI integration (~100 lines)
- Tests (~400 lines)
- **Total:** ~1,550 lines

**Documentation:**
- README.md updates (~50 lines)
- ARCHITECTURE.md IPv6 section (~80 lines)
- CHANGELOG.md entry (~40 lines)
- CLAUDE.local.md updates (~30 lines)
- **Total:** ~200 lines

**Expected Test Count:** 965 → 985 (+20 tests)

### Sprint 4.21 ROI: 6.8/10
- **Strategic:** Enterprise deployments increasingly require IPv6
- **User Impact:** Future-proofing, government contracts mandate IPv6 support
- **Effort:** Medium (3-4 days)
- **Competitive:** Addresses gap, achieves parity with Nmap/RustScan/Naabu

---

## Sprint 4.22: Error Handling & Resilience (~3-4 days, LOW priority)

**Why Fifth:** Production hardening before v0.4.0 release

### Objectives (from docs/01-ROADMAP.md + docs/19-PHASE4-ENHANCEMENTS.md)
- Comprehensive error messages with context
- Recovery mechanisms for network failures
- Retry logic with exponential backoff
- Graceful degradation under resource constraints

### Background
Production-grade error handling:
- Reduces user confusion with clear error messages
- Enables recovery from transient failures
- Prevents crashes under resource pressure
- Improves reliability for long-running scans

### Tasks (3-4 days total)

#### TASK 1: Error Context Enhancement (1.5 days)
**Goal:** Add contextual error messages with actionable suggestions

**Actions:**
- Update `crates/prtip-core/src/error.rs` (~200 lines enhanced)
- Add error context fields:
  - File path (for file I/O errors)
  - Line number (for debugging)
  - Operation name (what was being attempted)
  - Target information (IP, port, etc.)
- Enhance error categorization (build on existing system from Sprint 4.11):
  - NetworkError (connection timeout, host unreachable)
  - PermissionError (CAP_NET_RAW missing, file access denied)
  - ConfigError (invalid arguments, bad config file)
  - ResourceError (out of memory, file descriptors exhausted)
  - ScannerError (packet parse failure, protocol error)
- Add actionable suggestions:
  - "Permission denied: Run with sudo or add CAP_NET_RAW capability"
  - "Connection timeout: Try increasing --timeout or reducing --max-rate"
  - "File not found: Ensure directory exists and path is correct"
- User-friendly error display:
  - Human-readable error messages
  - Debug output with full context (--verbose flag)
  - Error codes for programmatic handling

**Code Skeleton:**
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ProRtIpError {
    #[error("Network error: {message}")]
    Network {
        message: String,
        target: Option<IpAddr>,
        port: Option<u16>,
        suggestion: String,
    },

    #[error("Permission denied: {operation}")]
    Permission {
        operation: String,
        required: String,
        suggestion: String,
    },

    #[error("Configuration error: {message}")]
    Config {
        message: String,
        field: Option<String>,
        suggestion: String,
    },

    #[error("Resource exhausted: {resource}")]
    Resource {
        resource: String,
        limit: Option<usize>,
        current: Option<usize>,
        suggestion: String,
    },

    // ... other error types
}

impl ProRtIpError {
    pub fn network_timeout(target: IpAddr, port: u16) -> Self {
        Self::Network {
            message: format!("Connection timeout to {}:{}", target, port),
            target: Some(target),
            port: Some(port),
            suggestion: "Try increasing --timeout or reducing --max-rate".to_string(),
        }
    }

    pub fn permission_cap_net_raw() -> Self {
        Self::Permission {
            operation: "Create raw socket".to_string(),
            required: "CAP_NET_RAW capability".to_string(),
            suggestion: "Run with sudo or: sudo setcap cap_net_raw+ep /path/to/prtip".to_string(),
        }
    }

    pub fn display_friendly(&self) -> String {
        // Human-readable error message with suggestion
        match self {
            Self::Network { message, suggestion, .. } => {
                format!("{}\nSuggestion: {}", message, suggestion)
            }
            Self::Permission { operation, required, suggestion } => {
                format!("Permission denied: {}\nRequired: {}\nSuggestion: {}",
                    operation, required, suggestion)
            }
            // ... other cases
        }
    }
}
```

**Testing:**
- Unit test: Network timeout error with suggestion
- Unit test: Permission error with CAP_NET_RAW suggestion
- Unit test: Config error with field name and suggestion
- Unit test: Resource error with limit and current values
- Unit test: Error display shows suggestion
- Integration test: Trigger permission error, verify suggestion appears

**Files Modified:**
- `crates/prtip-core/src/error.rs` (~200 lines enhanced)
- Error usage sites across codebase (~100 lines updates)

---

#### TASK 2: Recovery Mechanisms (1 day)
**Goal:** Implement retry logic and recovery mechanisms for network failures

**Actions:**
- Create `crates/prtip-scanner/src/retry.rs` (NEW, ~300 lines)
- Implement retry logic with exponential backoff:
  - Configurable max retries (default: 3)
  - Exponential backoff: 1s, 2s, 4s, 8s, ...
  - Jitter: Add random ±25% to prevent thundering herd
  - Per-target retry tracking
- Implement timeout handling improvements:
  - Adaptive timeouts based on RTT
  - Increase timeout on retry
  - Reset timeout on successful response
- Implement circuit breaker pattern:
  - Track failure rate per target
  - Open circuit after N consecutive failures (stop scanning target)
  - Half-open circuit after cooldown period (retry)
  - Close circuit on successful response
- Add automatic fallback strategies:
  - SYN scan → Connect scan (if raw sockets fail)
  - IPv6 → IPv4 (if IPv6 unreachable)
  - Full probe → partial probe (if timeout)

**Code Skeleton:**
```rust
pub struct RetryConfig {
    pub max_retries: usize,
    pub initial_backoff: Duration,
    pub max_backoff: Duration,
    pub jitter_percent: f32,
}

pub struct RetryStrategy {
    config: RetryConfig,
    attempt: usize,
}

impl RetryStrategy {
    pub async fn retry<F, T, E>(&mut self, mut operation: F) -> Result<T, E>
    where
        F: FnMut() -> Result<T, E>,
    {
        loop {
            match operation() {
                Ok(result) => return Ok(result),
                Err(err) if self.attempt >= self.config.max_retries => return Err(err),
                Err(_) => {
                    self.attempt += 1;
                    let backoff = self.calculate_backoff();
                    tokio::time::sleep(backoff).await;
                }
            }
        }
    }

    fn calculate_backoff(&self) -> Duration {
        let base = self.config.initial_backoff.as_millis() as f32
            * 2_f32.powi(self.attempt as i32);
        let jitter = 1.0 + (rand::random::<f32>() - 0.5) * self.config.jitter_percent * 2.0;
        let backoff_ms = (base * jitter).min(self.config.max_backoff.as_millis() as f32);
        Duration::from_millis(backoff_ms as u64)
    }
}

pub struct CircuitBreaker {
    failure_threshold: usize,
    cooldown: Duration,
    consecutive_failures: usize,
    state: CircuitState,
    last_failure: Option<Instant>,
}

pub enum CircuitState {
    Closed,   // Normal operation
    Open,     // Failing, stop trying
    HalfOpen, // Testing if recovered
}

impl CircuitBreaker {
    pub fn record_success(&mut self) {
        self.consecutive_failures = 0;
        self.state = CircuitState::Closed;
    }

    pub fn record_failure(&mut self) {
        self.consecutive_failures += 1;
        if self.consecutive_failures >= self.failure_threshold {
            self.state = CircuitState::Open;
            self.last_failure = Some(Instant::now());
        }
    }

    pub fn should_attempt(&mut self) -> bool {
        match self.state {
            CircuitState::Closed => true,
            CircuitState::Open => {
                if let Some(last_failure) = self.last_failure {
                    if last_failure.elapsed() > self.cooldown {
                        self.state = CircuitState::HalfOpen;
                        true
                    } else {
                        false
                    }
                } else {
                    false
                }
            }
            CircuitState::HalfOpen => true,
        }
    }
}
```

**Testing:**
- Unit test: Retry with exponential backoff (1s, 2s, 4s)
- Unit test: Retry with jitter (verify random variation)
- Unit test: Max retries reached, returns error
- Unit test: Circuit breaker opens after N failures
- Unit test: Circuit breaker half-open after cooldown
- Unit test: Circuit breaker closes on success
- Integration test: Network failure triggers retry
- Integration test: Circuit breaker prevents excessive retries

**Files Modified:**
- `crates/prtip-scanner/src/retry.rs` (NEW, ~300 lines)
- `crates/prtip-scanner/src/lib.rs` (+1 line: `pub mod retry;`)
- Scanner integration (~50 lines)

---

#### TASK 3: Resource Constraint Handling (0.5-1 day)
**Goal:** Implement graceful degradation under resource constraints

**Actions:**
- Create `crates/prtip-core/src/resilience.rs` (NEW, ~200 lines)
- Implement memory pressure detection:
  - Monitor memory usage via /proc/self/status (Linux)
  - Reduce batch sizes when memory >80% used
  - Trigger garbage collection (Vec::shrink_to_fit)
  - Warn user when approaching memory limits
- Implement file descriptor monitoring:
  - Detect ulimit exhaustion (already have ulimit detection from Cycle 3)
  - Reduce max concurrent connections
  - Warn user to increase ulimit
- Implement disk space monitoring:
  - Check available space before writing large files (PCAPNG, SQLite)
  - Warn user when disk space <1GB
  - Fail gracefully (don't corrupt files)
- Add connection pool adjustments:
  - Dynamically reduce pool size when resources constrained
  - Increase pool size when resources available
  - Track pool utilization (warn if always maxed out)

**Code Skeleton:**
```rust
pub struct ResourceMonitor {
    memory_threshold: f32,  // 0.8 = 80%
    disk_space_threshold: u64,  // 1GB
}

impl ResourceMonitor {
    pub fn check_memory_pressure(&self) -> Result<MemoryStatus> {
        let usage = get_memory_usage()?;
        let total = get_total_memory()?;
        let percent = usage as f32 / total as f32;

        if percent > self.memory_threshold {
            Ok(MemoryStatus::HighPressure {
                usage,
                total,
                percent,
                suggestion: "Reduce --batch-size or --max-concurrent".to_string(),
            })
        } else {
            Ok(MemoryStatus::Normal { usage, total })
        }
    }

    pub fn check_disk_space(&self, path: &Path) -> Result<DiskStatus> {
        let available = get_available_space(path)?;

        if available < self.disk_space_threshold {
            Ok(DiskStatus::LowSpace {
                available,
                threshold: self.disk_space_threshold,
                suggestion: "Free up disk space or change output directory".to_string(),
            })
        } else {
            Ok(DiskStatus::Sufficient { available })
        }
    }
}

pub fn adjust_batch_size(current: usize, memory_status: &MemoryStatus) -> usize {
    match memory_status {
        MemoryStatus::HighPressure { .. } => current / 2,  // Reduce by 50%
        MemoryStatus::Normal { .. } => current,
    }
}
```

**Testing:**
- Unit test: Memory pressure detection (mock /proc/self/status)
- Unit test: Disk space monitoring (mock filesystem)
- Unit test: Batch size adjustment under pressure
- Unit test: Connection pool adjustment
- Integration test: Simulate memory pressure, verify batch size reduced
- Integration test: Simulate low disk space, verify warning

**Files Modified:**
- `crates/prtip-core/src/resilience.rs` (NEW, ~200 lines)
- `crates/prtip-core/src/lib.rs` (+1 line: `pub mod resilience;`)
- Scanner integration (~40 lines)

---

#### TASK 4: Testing & Documentation (1 day)
**Goal:** Comprehensive testing and documentation for error handling

**Actions:**
- Create comprehensive unit tests (15+):
  - Test all error types with context
  - Test retry logic with various failure patterns
  - Test circuit breaker state transitions
  - Test resource monitoring and adjustment
  - Test graceful degradation scenarios
- Create integration tests:
  - Trigger network errors, verify recovery
  - Trigger permission errors, verify suggestions
  - Trigger resource exhaustion, verify adjustment
- Create `docs/ERROR-HANDLING.md` (~300 lines):
  - Overview of error handling strategy
  - Error categories and suggestions
  - Retry and recovery mechanisms
  - Circuit breaker explanation
  - Resource monitoring and adjustment
  - Troubleshooting common errors
- Update documentation:
  - README.md with error handling section
  - ARCHITECTURE.md with error handling design
  - CHANGELOG.md

**Test Cases:**
```rust
#[tokio::test]
async fn test_retry_with_exponential_backoff() {
    let mut retry = RetryStrategy::new(RetryConfig::default());
    let mut attempts = 0;

    let result = retry.retry(|| {
        attempts += 1;
        if attempts < 3 {
            Err("Temporary failure")
        } else {
            Ok("Success")
        }
    }).await;

    assert_eq!(result, Ok("Success"));
    assert_eq!(attempts, 3);
}

#[test]
fn test_circuit_breaker_opens_after_threshold() {
    let mut breaker = CircuitBreaker::new(3, Duration::from_secs(60));

    // 3 consecutive failures
    for _ in 0..3 {
        breaker.record_failure();
    }

    assert_eq!(breaker.state, CircuitState::Open);
    assert!(!breaker.should_attempt());
}

#[test]
fn test_memory_pressure_detection() {
    let monitor = ResourceMonitor::new();

    // Mock high memory usage
    let status = monitor.check_memory_pressure().unwrap();

    match status {
        MemoryStatus::HighPressure { suggestion, .. } => {
            assert!(suggestion.contains("--batch-size"));
        }
        _ => panic!("Expected high pressure"),
    }
}
```

**Documentation Outline (ERROR-HANDLING.md):**
```markdown
# ProRT-IP Error Handling

## Overview
Comprehensive error handling for production reliability.

## Error Categories

### Network Errors
- Connection timeout
- Host unreachable
- Packet loss
- Suggestions: Increase timeout, reduce rate

### Permission Errors
- CAP_NET_RAW missing
- File access denied
- Suggestions: Run with sudo, check permissions

### Configuration Errors
- Invalid arguments
- Bad config file
- Suggestions: Check syntax, refer to examples

### Resource Errors
- Out of memory
- File descriptors exhausted
- Disk space low
- Suggestions: Reduce batch size, increase ulimit, free disk space

## Recovery Mechanisms

### Retry Logic
- Exponential backoff: 1s, 2s, 4s, 8s
- Jitter: ±25% random variation
- Max retries: 3 (configurable)

### Circuit Breaker
- Opens after N consecutive failures
- Half-open after cooldown period
- Closes on successful response

### Automatic Fallbacks
- SYN → Connect (if raw sockets fail)
- IPv6 → IPv4 (if IPv6 unreachable)

## Resource Monitoring

### Memory Pressure
- Reduce batch size when >80% used
- Trigger garbage collection
- Warn user

### Disk Space
- Check before large writes
- Warn when <1GB available
- Fail gracefully

### File Descriptors
- Reduce concurrency when nearing ulimit
- Warn user to increase ulimit

## Troubleshooting

### Common Errors
- "Permission denied: Run with sudo"
- "Connection timeout: Increase --timeout"
- "Out of memory: Reduce --batch-size"
- "File not found: Check path"
```

**Files Modified:**
- Unit tests (~200 lines)
- Integration tests (~100 lines)
- `docs/ERROR-HANDLING.md` (NEW, ~300 lines)
- `README.md` (~50 lines)
- `docs/00-ARCHITECTURE.md` (~60 lines)
- `CHANGELOG.md` (~40 lines)

---

### Sprint 4.22 Success Criteria

- ✅ Comprehensive error messages with context and suggestions
- ✅ Retry logic with exponential backoff working
- ✅ Circuit breaker prevents excessive retries
- ✅ Graceful degradation under resource constraints
- ✅ 15+ new error handling tests passing
- ✅ Error handling documentation complete (ERROR-HANDLING.md)
- ✅ Zero regressions (985/985 tests + new tests passing)

### Sprint 4.22 Deliverables

**Code:**
- Error context enhancements (~200 lines)
- Retry mechanisms (~300 lines)
- Resource monitoring (~200 lines)
- Integration (~90 lines)
- Tests (~300 lines)
- **Total:** ~1,090 lines

**Documentation:**
- ERROR-HANDLING.md (~300 lines)
- README.md updates (~50 lines)
- ARCHITECTURE.md error section (~60 lines)
- CHANGELOG.md entry (~40 lines)
- CLAUDE.local.md updates (~30 lines)
- **Total:** ~480 lines

**Expected Test Count:** 985 → 1,000 (+15 tests)

### Sprint 4.22 ROI: 6.5/10
- **Strategic:** Production hardening before v0.4.0 release
- **User Impact:** Better UX, fewer confusing errors, higher reliability
- **Effort:** Medium (3-4 days)
- **Quality:** Critical for production use, differentiates from hobby projects

---

## Sprint 4.23: Documentation & Release Prep v0.4.0 (~2-3 days, LOW priority)

**Why Last:** Polish before release, comprehensive documentation

### Objectives
- Complete user manual
- Update all documentation for v0.4.0 features
- Create example scan scenarios
- Prepare release notes and announcements
- Final testing and validation

### Tasks (2-3 days total)

#### TASK 1: Documentation Completion (1-1.5 days)
**Goal:** Update all documentation for v0.4.0 release

**Actions:**
- Update `README.md` (~200 lines updates):
  - Update version badge (v0.3.8 → v0.4.0)
  - Update test count (933 → 1,000+)
  - Update coverage (61.92% → 63-65%)
  - Add all v0.4.0 features:
    - SQLite query interface + export
    - PCAPNG packet capture (all scan types)
    - Fragmentation and evasion techniques
    - Full IPv6 support (dual-stack)
    - Enhanced error handling
  - Update installation instructions
  - Update quick start guide
  - Add v0.4.0 examples
- Complete `CHANGELOG.md` (~200 lines for v0.4.0):
  - Comprehensive v0.4.0 entry
  - List all 6 sprints (4.18.1, 4.18.4, 4.20-4.23)
  - Feature breakdown by sprint
  - Breaking changes (if any)
  - Migration guide (if needed)
  - Contributors and acknowledgments
- Create `USER-MANUAL.md` (NEW, ~1,000 lines):
  - Introduction and overview
  - Installation (all platforms)
  - Quick start tutorial
  - Target specification
  - Scan types (TCP, UDP, SYN, stealth, IPv6)
  - Output formats (6 formats)
  - Advanced features (fragmentation, evasion, PCAPNG, SQLite)
  - Performance tuning
  - Troubleshooting
  - FAQ
- Update numbered docs:
  - `docs/00-ARCHITECTURE.md`: Add v0.4.0 features
  - `docs/01-ROADMAP.md`: Mark Sprints 4.18-4.23 complete
  - `docs/10-PROJECT-STATUS.md`: Update to v0.4.0 status
  - `docs/06-TESTING.md`: Update test counts and coverage
  - Update other docs as needed
- Update `CLAUDE.local.md`:
  - Mark all 6 sprints complete
  - Update current status to v0.4.0 release-ready
  - Update metrics (tests, coverage, lines of code)

**Files Modified:**
- `README.md` (~200 lines updates)
- `CHANGELOG.md` (~200 lines for v0.4.0)
- `USER-MANUAL.md` (NEW, ~1,000 lines)
- `docs/00-ARCHITECTURE.md` (~100 lines updates)
- `docs/01-ROADMAP.md` (~50 lines updates)
- `docs/10-PROJECT-STATUS.md` (~100 lines updates)
- `docs/06-TESTING.md` (~50 lines updates)
- `CLAUDE.local.md` (~100 lines updates)
- **Total:** ~1,800 lines

---

#### TASK 2: Example Scenarios (0.5 day)
**Goal:** Create 10+ example scan scenarios for common use cases

**Actions:**
- Create `docs/EXAMPLES.md` (NEW, ~500 lines)
- Document 10+ real-world scan scenarios:
  1. **Quick Web Server Scan:**
     ```bash
     prtip -sS -p 80,443,8080,8443 target.com
     ```
  2. **Full Port Scan with Service Detection:**
     ```bash
     prtip -sS -p- -sV --version-intensity 9 target.com
     ```
  3. **Stealth Scan with Fragmentation:**
     ```bash
     prtip -sF -f --ttl 64 -p 1-1000 target.com
     ```
  4. **IPv6 Dual-Stack Scan:**
     ```bash
     prtip -sS -p 22,80,443 -6 target.com
     ```
  5. **PCAPNG Capture for Forensics:**
     ```bash
     prtip -sS -p 1-65535 --packet-capture scan.pcapng target.com
     ```
  6. **SQLite Query and Export Workflow:**
     ```bash
     # Scan to database
     prtip -sS -p 1-1000 --db scan.db target.com

     # Query results
     prtip query --db scan.db --sql "SELECT * FROM scan_results WHERE state='open'"

     # Export to CSV
     prtip export --db scan.db --format csv --output results.csv --filter "state='open'"
     ```
  7. **UDP Service Discovery:**
     ```bash
     prtip -sU -p 53,161,123,500 target.com
     ```
  8. **Evasion Techniques Combination:**
     ```bash
     prtip -sS -f --badsum -D RND:10 --ttl 128 -p 80,443 target.com
     ```
  9. **Aggressive Scan with All Detection:**
     ```bash
     prtip -A -p 1-1000 target.com
     # Equivalent to: -sS -sV -O --script=default
     ```
  10. **Network Range Scan:**
      ```bash
      prtip -sS -p 22,80,443 192.168.1.0/24
      ```
  11. **Timing Template Comparison:**
      ```bash
      # Paranoid (slowest, stealthiest)
      prtip -T0 -sS -p 80 target.com

      # Normal (balanced)
      prtip -T3 -sS -p 80 target.com

      # Insane (fastest, most aggressive)
      prtip -T5 -sS -p 80 target.com
      ```
  12. **Batch Scanning from File:**
      ```bash
      # Create target file
      echo "192.168.1.0/24" > targets.txt
      echo "10.0.0.0/24" >> targets.txt

      # Scan all targets
      prtip -sS -p 80,443 -iL targets.txt
      ```
- For each example:
  - Explain use case
  - Show command
  - Explain flags
  - Show expected output
  - Add troubleshooting tips

**Files Modified:**
- `docs/EXAMPLES.md` (NEW, ~500 lines)

---

#### TASK 3: Release Notes (0.5 day)
**Goal:** Prepare comprehensive v0.4.0 release notes

**Actions:**
- Create `RELEASE-NOTES-v0.4.0.md` (NEW, ~1,000 lines)
- Content structure:
  - **Executive Summary:** Major features, strategic impact
  - **What's New:** Detailed breakdown of all 6 sprints
  - **Sprint 4.18.1:** SQLite query interface + export
  - **Sprint 4.18.4:** Complete PCAPNG integration
  - **Sprint 4.20:** Fragmentation & evasion
  - **Sprint 4.21:** IPv6 complete implementation
  - **Sprint 4.22:** Error handling & resilience
  - **Sprint 4.23:** Documentation & release prep
  - **Performance Improvements:** Metrics and benchmarks
  - **Technical Details:** Architecture, implementation specifics
  - **Files Changed:** Comprehensive file list with line counts
  - **Testing & Quality:** Test counts, coverage, CI/CD status
  - **Documentation:** New/updated docs with line counts
  - **Strategic Value:** Impact on project goals and competition
  - **Installation:** Updated installation instructions
  - **Migration Guide:** Breaking changes (if any)
  - **Known Issues:** Documented limitations
  - **Future Work:** Phase 5 preview
  - **Contributors:** Acknowledgments
- Prepare GitHub release notes (markdown formatted, ~800 lines)
- Draft announcement blog post outline (~300 lines)

**Files Modified:**
- `RELEASE-NOTES-v0.4.0.md` (NEW, ~1,000 lines)
- GitHub release notes draft (separate, ~800 lines)
- Blog post outline (separate, ~300 lines)

---

#### TASK 4: Final Testing & Validation (0.5-1 day)
**Goal:** Comprehensive final testing before v0.4.0 release

**Actions:**
- Full test suite verification:
  - Run `cargo test --workspace` (expect 1,000+ tests passing)
  - Verify 100% pass rate
  - Check coverage (expect 63-65%)
  - Run ignored tests manually (CAP_NET_RAW tests)
- Manual testing of all v0.4.0 features:
  - SQLite query interface (test all query methods)
  - SQLite export (test CSV, JSON, XML)
  - PCAPNG capture (test all scan types, verify Wireshark)
  - Fragmentation (test -f, -ff, --mtu)
  - IPv6 (test dual-stack, IPv6-only, ICMPv6)
  - Error handling (trigger errors, verify suggestions)
- Cross-platform validation:
  - Linux: Full test suite + manual testing
  - Windows: CI tests + manual PCAPNG/SQLite testing
  - macOS: CI tests + manual dual-stack testing
- Performance regression check:
  - Run benchmark suite (hyperfine)
  - Compare against v0.3.8 baselines
  - Verify no >5% regressions
  - Document any performance changes
- Security audit checklist review:
  - Review `docs/08-SECURITY.md` checklist
  - Verify input validation (IP, CIDR, ports, filenames)
  - Verify privilege management (drop after raw socket creation)
  - Verify SQL injection prevention (parameter binding)
  - Verify file operations (no path traversal)
  - Run cargo audit (security vulnerabilities)
  - Run cargo deny (license compliance)
- CI/CD verification:
  - Verify all 7 CI jobs passing (format, clippy, test×3, MSRV, security)
  - Verify all 8 release targets building (Linux, macOS, Windows × x86_64/ARM64 × gnu/musl)
  - Verify no warnings or errors
- Final code quality checks:
  - Run cargo clippy (zero warnings)
  - Run cargo fmt --check (clean)
  - Check MSRV (Rust 1.85 compiles)
  - Review new dependencies (ensure necessary and vetted)
- Documentation review:
  - Verify all links work
  - Verify all examples run
  - Verify all code snippets compile
  - Spell check major docs
- Prepare for release:
  - Tag v0.4.0 in git (annotated tag with release notes)
  - Build release binaries (all 8 platforms)
  - Generate checksums (SHA256)
  - Create GitHub release (draft)
  - Upload artifacts to GitHub release

**Checklist:**
```markdown
## v0.4.0 Release Validation Checklist

### Code Quality
- [ ] All 1,000+ tests passing (100% pass rate)
- [ ] Coverage 63-65% (exceeds 60% target)
- [ ] Zero clippy warnings
- [ ] Clean rustfmt
- [ ] MSRV (Rust 1.85) builds successfully

### CI/CD
- [ ] 7/7 CI jobs passing (format, clippy, test×3, MSRV, security)
- [ ] 8/8 release targets building (all platforms)
- [ ] cargo audit clean (no security vulnerabilities)
- [ ] cargo deny clean (license compliance)

### Feature Testing
- [ ] SQLite query interface works (all query methods)
- [ ] SQLite export works (CSV, JSON, XML)
- [ ] PCAPNG capture works (UDP, SYN, stealth)
- [ ] PCAPNG files open in Wireshark
- [ ] Fragmentation works (-f, -ff, --mtu)
- [ ] IPv6 scanning works (dual-stack, IPv6-only)
- [ ] Error handling shows suggestions
- [ ] Retry logic recovers from failures

### Cross-Platform
- [ ] Linux tests passing (100%)
- [ ] Windows tests passing (expect ~29/29)
- [ ] macOS tests passing (100%)
- [ ] All platforms build release binaries

### Performance
- [ ] No regressions >5% vs v0.3.8
- [ ] Benchmark suite run and documented
- [ ] Memory usage acceptable (<100MB for common scans)

### Security
- [ ] Input validation verified
- [ ] Privilege management verified
- [ ] SQL injection prevention verified
- [ ] File operations safe (no path traversal)
- [ ] Security audit checklist complete

### Documentation
- [ ] README.md updated
- [ ] CHANGELOG.md v0.4.0 entry complete
- [ ] USER-MANUAL.md created
- [ ] EXAMPLES.md created with 10+ scenarios
- [ ] RELEASE-NOTES-v0.4.0.md comprehensive
- [ ] All docs reviewed and spell-checked
- [ ] All examples tested

### Release
- [ ] Git tag v0.4.0 created (annotated with release notes)
- [ ] Release binaries built (all 8 platforms)
- [ ] Checksums generated (SHA256)
- [ ] GitHub release created (draft)
- [ ] Artifacts uploaded to GitHub release
- [ ] Release notes on GitHub complete
```

**Files Modified:**
- No new files (validation only)
- Validation checklist (separate tracking document)

---

### Sprint 4.23 Success Criteria

- ✅ Comprehensive documentation for all v0.4.0 features
- ✅ USER-MANUAL.md complete (~1,000 lines)
- ✅ 10+ example scenarios documented (EXAMPLES.md)
- ✅ Release notes complete and comprehensive (RELEASE-NOTES-v0.4.0.md)
- ✅ All 1,000+ tests passing (100% pass rate)
- ✅ No regressions detected
- ✅ Cross-platform validation complete (Linux, Windows, macOS)
- ✅ Performance benchmarks within acceptable range
- ✅ Security audit checklist complete
- ✅ CI/CD all green (7/7 jobs, 8/8 platforms)
- ✅ Ready for v0.4.0 tag and release

### Sprint 4.23 Deliverables

**Documentation:**
- README.md updates (~200 lines)
- CHANGELOG.md v0.4.0 entry (~200 lines)
- USER-MANUAL.md (NEW, ~1,000 lines)
- EXAMPLES.md (NEW, ~500 lines)
- RELEASE-NOTES-v0.4.0.md (NEW, ~1,000 lines)
- docs/ updates (~400 lines)
- CLAUDE.local.md updates (~100 lines)
- GitHub release notes (~800 lines)
- Blog post outline (~300 lines)
- **Total:** ~4,500 lines

**Validation:**
- Full test suite run (1,000+ tests)
- Manual testing (all features)
- Cross-platform validation (3 platforms)
- Performance benchmarks
- Security audit

**Release Artifacts:**
- Git tag v0.4.0 (annotated)
- Release binaries (8 platforms)
- Checksums (SHA256)
- GitHub release (with artifacts and notes)

**Expected Test Count:** 1,000+ (no new tests, final count from previous sprints)

### Sprint 4.23 ROI: 6.0/10
- **Strategic:** Necessary for production release, enables adoption
- **User Impact:** Easier onboarding, better discoverability, professional presentation
- **Effort:** Low-medium (2-3 days)
- **Quality:** Critical for project success, first impressions matter

---

## Overall Plan Summary

### Sprint Sequence & Duration
1. **Sprint 4.18.1** (SQLite) - ~11 hours (~1.5 days)
2. **Sprint 4.18.4** (PCAPNG completion) - ~4-6 hours (~1 day)
3. **Sprint 4.20** (Fragmentation/Evasion) - ~4-5 days
4. **Sprint 4.21** (IPv6) - ~3-4 days
5. **Sprint 4.22** (Error Handling) - ~3-4 days
6. **Sprint 4.23** (Documentation/Release) - ~2-3 days

**Total Timeline:**
- **Minimum:** 15.5 days (optimistic, everything goes smoothly)
- **Maximum:** 21.5 days (realistic with testing/debugging)
- **Target:** 18-20 days (~3-4 weeks to v0.4.0)

### Code & Documentation Growth

**Current State (v0.3.8):**
- Tests: 933 (61.92% coverage)
- Lines of Code: ~25,000
- Documentation: 158+ markdown files

**Expected State (v0.4.0):**
- Tests: 1,000+ (63-65% coverage)
- Lines of Code: ~29,000-30,000
- Documentation: 170+ markdown files

**New Code by Sprint:**
- Sprint 4.18.1: ~780 lines (SQLite)
- Sprint 4.18.4: ~175 lines (PCAPNG completion)
- Sprint 4.20: ~1,250 lines (Fragmentation/Evasion)
- Sprint 4.21: ~1,550 lines (IPv6)
- Sprint 4.22: ~1,090 lines (Error Handling)
- Sprint 4.23: 0 lines (documentation only)
- **Total:** ~4,845 lines new code

**New Documentation by Sprint:**
- Sprint 4.18.1: ~320 lines (SQLITE-QUERIES.md)
- Sprint 4.18.4: ~520 lines (OUTPUT-FORMATS.md)
- Sprint 4.20: ~420 lines (EVASION-TECHNIQUES.md)
- Sprint 4.21: ~200 lines (README/ARCHITECTURE updates)
- Sprint 4.22: ~480 lines (ERROR-HANDLING.md)
- Sprint 4.23: ~4,500 lines (USER-MANUAL, EXAMPLES, RELEASE-NOTES)
- **Total:** ~6,440 lines new documentation

**Test Growth by Sprint:**
- Sprint 4.18.1: +10 tests (933 → 943)
- Sprint 4.18.4: +7 tests (943 → 950)
- Sprint 4.20: +15 tests (950 → 965)
- Sprint 4.21: +20 tests (965 → 985)
- Sprint 4.22: +15 tests (985 → 1,000)
- Sprint 4.23: 0 new tests (validation only)
- **Total:** +67 tests (933 → 1,000)

### v0.4.0 Feature Set (Complete List)

**From Sprint 4.18.1 (SQLite):**
- ✅ Database indexes (100x query speedup)
- ✅ Query interface module (ScanQuery)
- ✅ CLI query subcommand (`prtip query`)
- ✅ Export utilities (CSV, JSON, XML)
- ✅ Streaming export (constant memory)

**From Sprint 4.18.4 (PCAPNG):**
- ✅ PCAPNG capture for UDP scanner
- ✅ PCAPNG capture for SYN scanner
- ✅ PCAPNG capture for Stealth scanners (FIN/NULL/Xmas/ACK)
- ✅ TCP Connect limitation documented
- ✅ OUTPUT-FORMATS.md comprehensive guide

**From Sprint 4.20 (Fragmentation/Evasion):**
- ✅ IP fragmentation (-f, -ff, --mtu)
- ✅ Fragment reassembly evasion
- ✅ TTL manipulation (--ttl)
- ✅ IP options insertion (LSR, SSR, RR, TS)
- ✅ Bad checksum generation (--badsum)

**From Sprint 4.21 (IPv6):**
- ✅ Full IPv6 packet building
- ✅ ICMPv6 neighbor discovery
- ✅ IPv6 scanning (SYN, Connect, UDP)
- ✅ Dual-stack support (IPv4 + IPv6)
- ✅ IPv6 extension headers

**From Sprint 4.22 (Error Handling):**
- ✅ Comprehensive error messages with context
- ✅ Actionable suggestions for common errors
- ✅ Retry logic with exponential backoff
- ✅ Circuit breaker pattern
- ✅ Graceful degradation under resource constraints

**From Sprint 4.23 (Documentation):**
- ✅ USER-MANUAL.md (1,000 lines)
- ✅ EXAMPLES.md (10+ scenarios)
- ✅ RELEASE-NOTES-v0.4.0.md (comprehensive)
- ✅ All documentation updated
- ✅ Final testing and validation

### Deferred to Phase 5

**Not in v0.4.0 scope:**
- Idle scan implementation (-sI) - Phase 5 Sprint 5.1
- Lua plugin system (NSE compatibility) - Phase 5 Sprint 5.3
- TUI interface (ratatui) - Phase 6
- XDP/eBPF integration - Phase 5 Sprint 5.4
- Complete OS fingerprinting (2,600+ signatures) - Phase 5 Sprint 5.1
- Real-time PCAPNG streaming to Wireshark - Phase 5
- Advanced scripting engine - Phase 5 Sprint 5.3

### Success Metrics for v0.4.0

**Quality Metrics:**
- ✅ 1,000+ tests passing (100% pass rate)
- ✅ 63-65% code coverage (exceeds 60% target)
- ✅ Zero critical bugs
- ✅ Zero clippy warnings
- ✅ Clean rustfmt

**CI/CD Metrics:**
- ✅ 7/7 CI jobs passing (format, clippy, test×3, MSRV, security)
- ✅ 8/8 release platforms building (Linux, macOS, Windows × gnu/musl × x86_64/ARM64)
- ✅ cargo audit clean (no security vulnerabilities)
- ✅ cargo deny clean (license compliance)

**Feature Completeness:**
- ✅ Complete PCAPNG packet capture (all scan types except TCP Connect)
- ✅ SQLite query interface + export utilities
- ✅ Fragmentation and evasion toolkit
- ✅ Full IPv6 support (dual-stack)
- ✅ Production-grade error handling
- ✅ Comprehensive documentation (170+ markdown files)
- ✅ Competitive feature parity with Nmap (most features)

**Documentation Metrics:**
- ✅ USER-MANUAL.md (1,000 lines)
- ✅ 10+ example scenarios (EXAMPLES.md)
- ✅ Comprehensive release notes (RELEASE-NOTES-v0.4.0.md)
- ✅ All features documented
- ✅ API documentation complete (cargo doc)

### Strategic Impact

**Competitive Position:**
- Addresses 5 of 7 critical gaps identified in Phase 4 analysis
- Achieves feature parity with Nmap for most use cases
- Maintains Rust safety advantage over C/C++ scanners
- Superior testing infrastructure vs all competitors (1,000+ tests)

**User Impact:**
- SQLite query interface enables custom reporting and analysis
- PCAPNG capture enables Wireshark workflow for forensics
- Fragmentation/evasion enables advanced security testing
- IPv6 support enables enterprise and government deployments
- Error handling improves user experience and reliability

**Project Maturity:**
- Production-ready quality (1,000+ tests, comprehensive docs)
- Professional presentation (USER-MANUAL, examples, release notes)
- Enterprise-grade features (IPv6, error handling, resilience)
- Ready for wider adoption and community contributions

---

## Execution Plan

### Recommended Approach

1. **Start with Sprint 4.18.1 (SQLite)** - Quick win, immediate value, no blockers
2. **Continue to Sprint 4.18.4 (PCAPNG)** - Complete deferred work from 4.18.3
3. **Proceed to Sprint 4.20 (Fragmentation)** - Competitive gap closure
4. **Move to Sprint 4.21 (IPv6)** - Future-proofing
5. **Follow with Sprint 4.22 (Error Handling)** - Production hardening
6. **Finish with Sprint 4.23 (Documentation)** - Polish and release

### Risk Mitigation

**Technical Risks:**
- IPv6 complexity may extend Sprint 4.21 timeline
- PCAPNG TCP Connect limitation may require extra documentation
- Fragmentation implementation may have platform-specific issues

**Mitigation:**
- Allocate buffer time (18-20 days vs 15.5-21.5 range)
- Test early and often on all platforms
- Document limitations clearly (don't hide them)

**Quality Risks:**
- Test count may not reach 1,000 (currently 933, adding 67)
- Coverage may not reach 65% (currently 61.92%)

**Mitigation:**
- Focus on integration tests (higher value than unit tests)
- Prioritize testing critical paths (error handling, IPv6)
- Accept 63%+ coverage as success (still exceeds 60% target)

### Communication Plan

**During Development:**
- Update CLAUDE.local.md after each sprint
- Commit regularly with descriptive messages
- Create sprint summary documents in /tmp/ProRT-IP/

**At Release:**
- Create comprehensive RELEASE-NOTES-v0.4.0.md
- Update GitHub release with full notes and artifacts
- Post announcement (Reddit r/rust, r/netsec, Hacker News)
- Update project README with v0.4.0 highlights

---

## Conclusion

This comprehensive 6-sprint plan delivers a production-ready v0.4.0 release with competitive feature parity, addressing critical gaps identified in the Phase 4 competitive analysis. The ordered approach (SQLite → PCAPNG → Fragmentation → IPv6 → Error Handling → Documentation) maximizes ROI while minimizing dependencies and blockers.

**Key Takeaways:**
- **Timeline:** 18-20 days (~3-4 weeks)
- **Tests:** 933 → 1,000+ (7% growth, 100% pass rate)
- **Coverage:** 61.92% → 63-65% (exceeds 60% target)
- **Code:** ~25,000 → ~29,000-30,000 lines (20% growth)
- **Docs:** 158+ → 170+ files (comprehensive coverage)
- **Quality:** Production-ready, enterprise-grade, competitive parity

**Ready to Begin Sprint 4.18.1!**
