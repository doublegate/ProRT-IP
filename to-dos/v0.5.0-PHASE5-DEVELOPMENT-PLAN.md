# ProRT-IP Phase 5 Development Plan
**Version:** v0.5.0-PLAN
**Created:** 2025-10-28
**Phase 4 Complete:** v0.4.0 (2025-10-27)
**Phase 5 Target:** v0.5.0 (Q1 2026, estimated: 2026-02-15)
**Planning Effort:** 8 hours comprehensive analysis

---

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [Phase 5 Overview](#phase-5-overview)
3. [Strategic Objectives](#strategic-objectives)
4. [Sprint Roadmap](#sprint-roadmap)
5. [Detailed Sprint Plans](#detailed-sprint-plans)
6. [Phase Completion Criteria](#phase-completion-criteria)
7. [Risk Assessment](#risk-assessment)
8. [Resource Requirements](#resource-requirements)
9. [Timeline & Milestones](#timeline--milestones)
10. [Appendices](#appendices)

---

## Executive Summary

**Phase 5 Mission:** Achieve feature completeness and production quality for ProRT-IP v0.5.0, delivering Nmap-equivalent capabilities with modern performance, complete IPv6 support, extensibility through plugins, and industry-standard test coverage.

**Key Objectives:**
- **Complete IPv6 Support:** Full scanner integration for SYN, UDP, Stealth, Discovery, Decoy (80% → 100% coverage)
- **Fill Critical Gaps:** Implement Idle scanning for anonymity, missing from v0.4.0
- **Enhance Quality:** Increase code coverage from 62.5% → 80% with comprehensive fuzz testing
- **Enable Extensibility:** Lua plugin system for custom service detection and post-processing
- **Maintain Excellence:** Zero regressions, <5% performance overhead, 100% test pass rate

**Deliverables:**
- **10 core sprints** delivering production-ready features
- **3 optional sprints** for enhanced user experience (defer to v0.6.0 if needed)
- **212+ new tests** (1,338 → 1,550+, +16% growth)
- **5 comprehensive guides** (IPv6, Idle Scan, Plugins, Fuzzing, Benchmarking)
- **8% coverage improvement** (62.5% → 80%)

**Timeline:** 6-8 weeks (156-189 hours core development)
**Estimated Effort:**
- **Core:** 156-189 hours (10 sprints)
- **Optional:** 39-56 hours (3 sprints)
- **Total:** 195-245 hours

**Strategic Value:**
Phase 5 positions ProRT-IP as a production-ready Nmap alternative with modern Rust safety, complete IPv6 support for cloud-native environments, extensibility through community plugins, and industry-leading quality metrics. By completing idle scanning, IPv6 integration, and plugin infrastructure, ProRT-IP achieves feature parity with established tools while offering superior performance (1M+ pps), memory safety, and extensibility.

The 80% code coverage target (industry standard for critical security tools) combined with comprehensive fuzz testing ensures production stability. The plugin system opens community contribution pathways, accelerating feature development beyond core team capacity. This phase delivers the foundation for v1.0 release readiness in Phase 7.

**Critical Success Factor:** Prioritizing IPv6 completion (unfinished Phase 4 business) and quality infrastructure (coverage + fuzzing) before plugin system ensures stable foundation for extensibility.

---

## Phase 5 Overview

### Context: Phase 4 Achievements

ProRT-IP v0.4.0 (released 2025-10-27) completed Phase 4 with exceptional results:

- **Quality Metrics:** 1,338 tests (100% passing), 62.5% coverage, 0 clippy warnings, 0 production panics
- **CI/CD:** 7/7 jobs passing, 8/8 release platforms production-ready
- **Performance:** 15% packet building improvement (68.3ns → 58.8ns), zero-copy architecture
- **Features:** Error handling (circuit breaker, retry, resource monitoring), network evasion (5/5 Nmap techniques), PCAPNG capture, NUMA optimization
- **IPv6 Foundation:** TCP Connect support (30% coverage), packet building infrastructure complete

**Phase 4 Gaps Identified:**
- IPv6 incomplete (5 of 6 scanners pending: SYN, UDP, Stealth, Discovery, Decoy)
- Idle scan missing (critical Nmap feature for anonymity)
- Plugin system not started (extensibility gap)
- Code coverage at 62.5% (target: 80% for v1.0)
- No fuzz testing infrastructure (security risk for packet parsers)

### Phase 5 Scope

**What's Included:**
- Complete IPv6 support for all scanner types (100% coverage)
- Idle scanning implementation (zombie host technique)
- Service detection enhancement (70% → 85-90% rate)
- Code coverage sprint (62.5% → 80%)
- Fuzz testing infrastructure (TCP/UDP/IPv6/TLS parsers)
- Plugin system foundation (Lua scripting via mlua)
- Advanced rate limiting (adaptive throttling)
- TLS certificate analysis (security auditing)
- Benchmarking suite (regression detection)
- Documentation updates (5 new guides)

**What's Excluded (Deferred to v0.6.0+):**
- Interactive TUI interface (ratatui-based) → v0.6.0
- Additional CLI enhancements → v0.6.0
- HTML/Markdown/CSV output formats → v0.6.0
- Web interface → Phase 8 (post-v1.0)
- Desktop GUI → Phase 8 (post-v1.0)

**Boundaries:**
- Focus on feature completeness and quality (not UI enhancements)
- Maintain <5% performance regression threshold
- Prioritize security (fuzz testing) over convenience (TUI)
- Plugin system foundation only (5 example plugins, not marketplace)

### Success Definition

**Phase 5 is complete when:**
1. ✅ All 6 scanner types support IPv6 (SYN, UDP, Stealth, Discovery, Decoy, Connect)
2. ✅ Idle scan (-sI flag) fully functional with zombie host discovery
3. ✅ Service detection rate ≥85% (from 70-80%)
4. ✅ Code coverage ≥80% overall (from 62.5%)
5. ✅ Fuzz testing finds and fixes 0 crashes in production parsers
6. ✅ Plugin system runs 5+ example Lua scripts successfully
7. ✅ Benchmarking suite detects <5% regressions automatically
8. ✅ 1,550+ tests passing (from 1,338, +16% growth)
9. ✅ Documentation: 5 new guides (IPv6, Idle, Plugins, Fuzzing, Benchmarking)
10. ✅ CI/CD: 7/7 jobs passing, 8/8 release platforms building

**Quality Bar:**
- Zero clippy warnings (maintain strict)
- Zero production panics (maintain strict)
- <5% performance regression vs v0.4.0
- 100% public API documentation (rustdoc)

### Source Document Analysis

This plan synthesizes 5 primary source documents and 9 secondary references:

**Primary Sources (Analyzed in Detail):**
1. **docs/20-PHASE4-ENHANCEMENTS.md** (12,500 words)
   - Competitive analysis vs 4 major tools (Nmap, Masscan, RustScan, Naabu)
   - 8 enhancement sprints with ROI scores (6.5-9.2/10)
   - Duration estimates: 2-6 days per sprint

2. **docs/22.1-CLAUDE-POST-PHASE4_1of2.md** (18,000 words)
   - Critical gap analysis: Idle scan, IPv6 completion, plugin system
   - Testing gaps: Fuzzing, property-based, E2E suite
   - 4 critical reviews: unsafe audit, dependency audit, license check, module cohesion

3. **docs/22.2-CLAUDE-POST-PHASE4_2of2.md** (continuation)
   - Performance recommendations: io_uring, benchmark regression tests
   - Documentation gaps: man pages, video tutorials, case studies
   - Strategic prioritization for Phase 5 vs Phase 6

4. **docs/01-ROADMAP.md** (8-phase project roadmap)
   - Phase 5 baseline: Weeks 14-16, Advanced Features
   - Original items: Idle scan, decoys (✅ done), fragmentation (✅ done), plugins

5. **docs/PHASE-5-BACKLOG.md** (deferred from Phase 4)
   - Sprint 5.X: IPv6 completion (25-30h, 4-phase breakdown)
   - Sprint 5.Y: Idle scan (8-10h)
   - Sprint 5.Z: Plugin system (15-20h)
   - Sprint 5.A: TUI (10-12h)

**Secondary Sources (Context):**
- README.md: Current v0.4.0 capabilities
- CHANGELOG.md: Recent sprint history
- CLAUDE.md: Project guidance
- CLAUDE.local.md: Current status
- ref-docs/: Technical specifications

**Synthesis Methodology:**
1. Read all source documents (90 minutes)
2. Extract sprint definitions, ROI scores, dependencies (45 minutes)
3. Sequential thinking analysis for prioritization (90 minutes)
4. Create knowledge graph of entities and relations (30 minutes)
5. Research external libraries (Context7: mlua, ratatui, pnet) (45 minutes)
6. Consolidate and sequence sprints optimally (60 minutes)
7. Generate comprehensive plan with detailed breakdowns (4 hours)

**Key Findings:**
- IPv6 appears in all 5 primary sources (consensus: HIGH priority)
- Idle scan missing from v0.4.0 (critical Nmap parity gap)
- Plugin system has HIGHEST ROI (9.2/10) but requires stable API
- Code coverage + fuzzing needed before plugin system (quality foundation)
- TUI can defer to v0.6.0 (CLI sufficient for pentesting use case)

---

## Strategic Objectives

### 1. Feature Completeness: Nmap Parity for Core Scanning

**Goal:** Achieve 100% feature parity with Nmap for essential scanning capabilities.

**Current State (v0.4.0):**
- ✅ TCP scanning: SYN, Connect, FIN, NULL, Xmas, ACK (100%)
- ✅ UDP scanning: Protocol-specific probes (100%)
- ✅ Evasion: Fragmentation, TTL, bad checksums, decoys, source port (100%)
- ⏸️ IPv6: TCP Connect only (16.7% of scanners)
- ❌ Idle scan: Not implemented (0%)
- ⏸️ Service detection: 70-80% rate (good but not excellent)

**Phase 5 Deliverables:**
- Complete IPv6 for all 6 scanner types (16.7% → 100%)
- Implement idle scanning (0% → 100%)
- Enhance service detection (70% → 85-90% rate)
- Result: **100% Nmap core feature parity**

**Strategic Value:**
- Penetration testers can replace Nmap with ProRT-IP for all common tasks
- IPv6 support enables cloud-native reconnaissance (AWS, GCP, Azure increasingly IPv6)
- Idle scanning provides anonymity for red team operations
- Enhanced service detection improves reconnaissance quality

**Success Metrics:**
- ✅ All Nmap scan types implemented
- ✅ IPv6 support for 100% of scanners
- ✅ Service detection rate ≥85% (vs Nmap's ~90%)
- ✅ Idle scan functional with zombie host discovery

### 2. Performance Excellence: Maintain Speed Leadership

**Goal:** Preserve 1M+ pps performance while adding features.

**Current State (v0.4.0):**
- ProRT-IP: 5.1ms (baseline, **fastest validated scanner**)
- Nmap: 150ms (29x slower)
- RustScan: 223ms (44x slower)
- Naabu: 2335ms (458x slower)

**Phase 5 Requirements:**
- IPv6 overhead: <10% vs IPv4 (minor header parsing acceptable)
- Plugin system overhead: <10% for script execution
- Fuzz testing: <1% overhead (compile-time only)
- Overall regression: <5% vs v0.4.0 baseline

**Strategic Value:**
- Maintain competitive advantage: "Fastest network scanner"
- Enable internet-scale scanning with new features (IPv6, plugins)
- Prove Rust safety doesn't sacrifice performance

**Success Metrics:**
- ✅ IPv6 scan speed ≥90% of IPv4
- ✅ Plugin execution adds <10% overhead
- ✅ Automated benchmark suite detects >5% regressions
- ✅ 1M+ pps maintained for stateless scanning

### 3. User Experience: Extensibility and Usability

**Goal:** Enable community contributions through plugin system and maintain CLI excellence.

**Current State (v0.4.0):**
- ✅ Git-style help system (9 categories, 50+ flags)
- ✅ User-friendly error messages (colored, recovery suggestions)
- ✅ Multiple output formats (Text, JSON, XML, Greppable, PCAPNG)
- ❌ No plugin system (0 extensibility)
- ⏸️ CLI-only (no TUI/GUI)

**Phase 5 Deliverables:**
- Lua plugin system with mlua (sandboxed, pre/post hooks)
- 5+ example plugins (HTTP enum, SSL checker, custom service detection)
- Plugin developer guide (600+ lines)
- Advanced rate limiting (automatic adaptive throttling)
- TLS certificate analysis (security auditing)

**Strategic Value:**
- Community can extend ProRT-IP without core team bottleneck
- Custom service detection for proprietary protocols
- Post-processing scripts for result transformation
- Competitive advantage vs Masscan/ZMap (no scripting), parity with Nmap NSE

**Success Metrics:**
- ✅ Plugin system runs 5+ example Lua scripts
- ✅ Plugin developer guide complete (600+ lines)
- ✅ Sandbox prevents filesystem/network access (security)
- ✅ Adaptive rate limiting reduces manual tuning

### 4. Quality & Reliability: Industry-Standard Test Coverage

**Goal:** Achieve 80% code coverage (industry standard for critical security tools).

**Current State (v0.4.0):**
- Tests: 1,338 passing (100% success rate)
- Coverage: 62.5% (exceeds 60% target but below industry standard)
- Clippy warnings: 0
- Production panics: 0
- No fuzz testing infrastructure

**Phase 5 Deliverables:**
- Code coverage sprint: 62.5% → 80% (+17.5 percentage points)
- Fuzz testing infrastructure: TCP/UDP/IPv6/TLS parsers
- 212+ new tests (1,338 → 1,550+, +16% growth)
- Property-based testing for parsers (proptest/quickcheck)

**Strategic Value:**
- 80% coverage = v1.0 release readiness
- Fuzz testing prevents production crashes from malformed packets
- Higher confidence for penetration testing use case (mission-critical)
- Reduce bug fix costs (catch issues before release)

**Success Metrics:**
- ✅ Code coverage ≥80% overall
- ✅ New code coverage ≥85%
- ✅ Fuzz testing: 0 crashes in 1M+ executions
- ✅ Fuzz coverage: >80% of parser code paths

### 5. Security & Compliance: Production Hardening

**Goal:** Harden parsers against malicious input, maintain zero-vulnerability status.

**Current State (v0.4.0):**
- ✅ Memory-safe Rust implementation (prevents entire vulnerability classes)
- ✅ Input validation for all CLI arguments
- ✅ Privilege dropping after socket creation
- ✅ Resource limits (ulimit-aware, adaptive parallelism)
- ❌ No fuzz testing (risk: malformed packet crashes)
- ⏸️ Unsafe code not audited

**Phase 5 Deliverables:**
- Fuzz testing infrastructure (cargo-fuzz + libFuzzer)
- 500+ malformed packet corpus (TCP, UDP, IPv6, TLS)
- TLS certificate analysis (weak cipher detection, protocol downgrade)
- Unsafe code audit (document or eliminate all unsafe blocks)

**Strategic Value:**
- Fuzz testing finds edge cases before attackers do
- TLS analysis enables security auditing use case
- Unsafe audit ensures memory safety guarantees hold
- Zero-vulnerability status maintains trust for security tools

**Success Metrics:**
- ✅ Fuzz testing: 0 crashes, 0 undefined behavior
- ✅ TLS analysis: Detects weak ciphers (RC4, 3DES, export)
- ✅ Unsafe blocks: 100% documented with SAFETY comments
- ✅ cargo audit: 0 known vulnerabilities

---

## Sprint Roadmap

### Sprint Sequence & Rationale

**Execution Order (10 Core + 3 Optional):**

```
WEEK 1-2: Foundation & Completion
├─ Sprint 5.1: IPv6 Scanner Completion (25-30h) → Unfinished Phase 4 business
└─ Sprint 5.2: Service Detection Enhancement (10-12h) → Quality improvement

WEEK 2-3: Critical Gaps
├─ Sprint 5.3: Idle Scan Implementation (15-18h) → Nmap parity
└─ Sprint 5.4: Advanced Rate Limiting (12-15h) → Operational improvement

WEEK 3-4: Security & Quality Foundation
├─ Sprint 5.5: TLS Certificate Analysis (10-12h) → Security auditing
├─ Sprint 5.6: Code Coverage Sprint (15-18h) → Quality foundation
└─ Sprint 5.7: Fuzz Testing Infrastructure (12-15h) → Security hardening

WEEK 5-6: Extensibility
└─ Sprint 5.8: Plugin System Foundation (20-25h) → Community enablement

WEEK 6-7: Validation & Documentation
├─ Sprint 5.9: Benchmarking Suite (18-24h) → Performance validation
└─ Sprint 5.10: Documentation & Polish (18-24h) → Release preparation

OPTIONAL (Defer to v0.6.0 if time-constrained):
├─ Sprint 5.11: Interactive TUI (15-20h) → UX enhancement
├─ Sprint 5.12: CLI Enhancement (12-18h) → Additional flags
└─ Sprint 5.13: Output Formats Enhancement (12-18h) → Reporting
```

**Rationale for Sequence:**

1. **IPv6 First (Sprint 5.1):** Unfinished business from Phase 4, no dependencies, high strategic value for cloud environments. Completing this early removes technical debt.

2. **Service Detection Second (Sprint 5.2):** Quick win (10-12h), improves reconnaissance quality for subsequent sprints, no dependencies.

3. **Idle Scan Third (Sprint 5.3):** Critical Nmap feature gap, no dependencies, enables anonymity testing. Completing early achieves competitive parity.

4. **Rate Limiting Fourth (Sprint 5.4):** Builds on existing rate limiter, improves stealth and reliability for all subsequent testing.

5. **TLS Analysis Fifth (Sprint 5.5):** Enhances service detection from Sprint 5.2, adds security auditing capability.

6. **Code Coverage Sixth (Sprint 5.6):** Establishes quality foundation before plugin system. Identifies gaps in Sprints 5.1-5.5 for immediate fixes.

7. **Fuzz Testing Seventh (Sprint 5.7):** Security hardening before plugin system. Ensures parsers (including new IPv6/Idle code) are robust.

8. **Plugin System Eighth (Sprint 5.8):** Requires stable API from Sprints 5.1-5.7. Complex (20-25h), deferred until foundation solid.

9. **Benchmarking Ninth (Sprint 5.9):** Validates performance across all new features. Requires all sprints complete for comprehensive baseline.

10. **Documentation Tenth (Sprint 5.10):** Final phase, all features complete. Comprehensive guides for IPv6, Idle, Plugins, Fuzzing, Benchmarking.

**Optional Sprints Deferral:**
- TUI (5.11), CLI Enhancement (5.12), Output Formats (5.13) provide user experience improvements but aren't required for v0.5.0 feature completeness.
- CLI is already mature (50+ flags), current output formats sufficient for pentesting.
- Defer to v0.6.0 focuses Phase 5 on core capabilities (IPv6, Idle, Plugins, Quality).

### Dependency Visualization

```
┌──────────────────────────────────────────────────────────────┐
│                      CRITICAL PATH                            │
└──────────────────────────────────────────────────────────────┘

5.1 IPv6          → NO DEPENDENCIES (start immediately)
  ↓
5.2 Service Det.  → NO DEPENDENCIES (parallel possible, but sequential for focus)
  ↓
5.3 Idle Scan     → NO DEPENDENCIES
  ↓
5.4 Rate Limit    → NO DEPENDENCIES
  ↓
5.5 TLS Analysis  → NO DEPENDENCIES
  ↓
5.6 Code Coverage → SOFT DEPENDENCY: All features benefit from more tests
  ↓
5.7 Fuzz Testing  → SOFT DEPENDENCY: Parser stability before plugins
  ↓
5.8 Plugin System → HARD DEPENDENCY: Requires stable API (5.1-5.7 complete)
  ↓
5.9 Benchmarking  → HARD DEPENDENCY: All features complete
  ↓
5.10 Documentation→ HARD DEPENDENCY: All features complete

OPTIONAL (No dependencies on critical path):
5.11 TUI          → Can start anytime, but defer to v0.6.0
5.12 CLI Enhance  → Can start anytime, but defer to v0.6.0
5.13 Output Fmt   → Can start anytime, but defer to v0.6.0
```

### Priority Matrix

| Sprint | ROI | Priority | Duration | Dependencies | Risk | Phase 5 Position |
|--------|-----|----------|----------|--------------|------|------------------|
| **5.1: IPv6 Completion** | 8.5/10 | **CRITICAL** | 25-30h | None | MEDIUM | #1 Foundation |
| **5.2: Service Detection** | HIGH | **HIGH** | 10-12h | None | LOW | #2 Quality |
| **5.3: Idle Scan** | 8.3/10 | **HIGH** | 15-18h | None | LOW | #3 Parity |
| **5.4: Rate Limiting** | MED-HIGH | **MEDIUM** | 12-15h | None | LOW | #4 Ops |
| **5.5: TLS Analysis** | MED-HIGH | **MEDIUM** | 10-12h | None | LOW | #5 Security |
| **5.6: Code Coverage** | HIGH | **HIGH** | 15-18h | Soft: 5.1-5.5 | MEDIUM | #6 Quality |
| **5.7: Fuzz Testing** | VERY HIGH | **CRITICAL** | 12-15h | Soft: 5.1-5.6 | LOW | #7 Security |
| **5.8: Plugin System** | 9.2/10 | **HIGH** | 20-25h | Hard: 5.1-5.7 | HIGH | #8 Extend |
| **5.9: Benchmarking** | 7.2/10 | **MEDIUM** | 18-24h | Hard: 5.1-5.8 | LOW | #9 Validate |
| **5.10: Documentation** | 7.5/10 | **MEDIUM** | 18-24h | Hard: 5.1-5.9 | LOW | #10 Release |
| 5.11: TUI | 8.8/10 | OPTIONAL | 15-20h | None | LOW | DEFER v0.6.0 |
| 5.12: CLI Enhance | 7.8/10 | OPTIONAL | 12-18h | None | LOW | DEFER v0.6.0 |
| 5.13: Output Formats | 6.5/10 | OPTIONAL | 12-18h | None | LOW | DEFER v0.6.0 |

**Priority Legend:**
- **CRITICAL:** Must complete for v0.5.0 release, high impact
- **HIGH:** Should complete for v0.5.0, significant value
- **MEDIUM:** Nice to have for v0.5.0, can defer if timeline slips
- **OPTIONAL:** Defer to v0.6.0 unless ahead of schedule

**Risk Legend:**
- **HIGH:** Complex, large scope, potential for timeline slip (mitigation: defer if needed)
- **MEDIUM:** Moderate scope, may uncover bugs (mitigation: budget contingency)
- **LOW:** Well-defined, proven patterns, unlikely to slip

### Phase Timeline

```
╔═══════════════════════════════════════════════════════════════╗
║                   PHASE 5 TIMELINE (7-8 weeks)                ║
╚═══════════════════════════════════════════════════════════════╝

WEEK 1: Sprint 5.1 IPv6 Completion (Part 1)
├─ Phase 1: SYN Scanner IPv6 (5h)
├─ Phase 2: UDP Scanner IPv6 (4h)
└─ Phase 3: Stealth Scanner IPv6 (4h)
Progress: [████████████░░░░░░░░] 50% Sprint 5.1

WEEK 2: Sprint 5.1 IPv6 Completion (Part 2) + Sprint 5.2
├─ 5.1 Phase 3: Stealth (cont.) + Discovery + Decoy + Integration (12-17h)
├─ 5.2: Service Detection Enhancement (10-12h)
Progress: [████████████████████] 100% Sprint 5.1, 5.2

WEEK 3: Sprint 5.3 Idle Scan + Sprint 5.4 Rate Limiting
├─ 5.3: Idle Scan Implementation (15-18h)
├─ 5.4: Advanced Rate Limiting (12-15h)
Progress: [████████████████████] 100% Sprint 5.3, 5.4

WEEK 4: Sprint 5.5 TLS + Sprint 5.6 Coverage (Part 1)
├─ 5.5: TLS Certificate Analysis (10-12h)
├─ 5.6: Code Coverage Sprint Phase 1-2 (8h)
Progress: [████████████████████] 100% Sprint 5.5, 50% Sprint 5.6

WEEK 5: Sprint 5.6 Coverage (Part 2) + Sprint 5.7 Fuzzing
├─ 5.6: Code Coverage Phase 3-4 (7-10h)
├─ 5.7: Fuzz Testing Infrastructure (12-15h)
Progress: [████████████████████] 100% Sprint 5.6, 5.7

WEEK 6: Sprint 5.8 Plugin System (Part 1)
├─ 5.8 Phase 1-3: Design + Integration + Example Plugins (15h)
Progress: [████████████░░░░░░░░] 60% Sprint 5.8

WEEK 7: Sprint 5.8 Plugin System (Part 2) + Sprint 5.9 Benchmarking
├─ 5.8 Phase 4-5: Sandboxing + Testing + Docs (10h)
├─ 5.9: Benchmarking Suite Phase 1-3 (12h)
Progress: [████████████████████] 100% Sprint 5.8, 60% Sprint 5.9

WEEK 8: Sprint 5.9 Benchmarking (Part 2) + Sprint 5.10 Documentation
├─ 5.9 Phase 4-5: Integration + Validation (10h)
├─ 5.10: Documentation & Polish (18-24h)
Progress: [████████████████████] 100% Sprint 5.9, 5.10

═══════════════════════════════════════════════════════════════
MILESTONE: Phase 5 Complete, v0.5.0 Ready for Release
═══════════════════════════════════════════════════════════════
```

**Timeline Notes:**
- Assumes 25-30 hours/week development capacity (full-time equivalent)
- Weeks 1-5: Feature development (Sprints 5.1-5.7)
- Weeks 6-7: Plugin system (complex, 20-25h)
- Week 8: Validation and documentation
- Optional sprints (5.11-5.13) add 2-3 weeks if included

**Critical Path:** All 10 core sprints are sequential (no parallelization opportunities due to dependencies). Any delays cascade to final timeline.

---

## Detailed Sprint Plans

### Sprint 5.1: IPv6 Scanner Completion

**Overview:**
- **Priority:** CRITICAL (unfinished Phase 4 business)
- **ROI Score:** 8.5/10 (ENHANCEMENTS) + 6.8/10 (BACKLOG) = HIGH
- **Duration:** 25-30 hours
- **Effort Breakdown:** 5h SYN + 8h UDP/Stealth + 7h Discovery/Decoy + 5h Integration/Docs
- **Dependencies:** NONE (foundation complete in Sprint 4.21)
- **Risk Level:** MEDIUM (large scope, but well-defined from BACKLOG)
- **Strategic Value:** Complete dual-stack scanning for cloud-native environments (AWS, GCP, Azure increasingly IPv6-first). Achieves 100% IPv6 coverage (from 30%).

**Rationale:**
IPv6 completion is sequenced first because:
1. Unfinished business from Phase 4 (Sprint 4.21 partial completion)
2. No dependencies on other Phase 5 work (can start immediately)
3. High strategic value: Cloud environments mandate IPv6 support
4. Detailed breakdown already exists in PHASE-5-BACKLOG.md (reduces planning overhead)
5. Removing technical debt early prevents IPv6 complications in later sprints

TCP Connect IPv6 (30% coverage) works for web services, SSH, databases. Remaining scanners (SYN, UDP, Stealth, Discovery, Decoy) cover advanced use cases: stealth scanning, UDP services, host discovery, anonymity techniques.

**Objectives:**
1. Complete IPv6 integration for 5 remaining scanner types (SYN, UDP, Stealth, Discovery, Decoy)
2. Add CLI flags for IPv6 control (-6, -4, --dual-stack)
3. Achieve ≥90% IPv6 scan speed vs IPv4 (minor header parsing overhead acceptable)
4. Create comprehensive IPv6 user guide (800+ lines)

**Tasks (Detailed 4-Phase Breakdown):**

#### Phase 1: SYN Scanner IPv6 (5 hours)

**Objective:** Add IPv6 support to SYN scanner with dual-stack management.

- [ ] **Task 1.1:** Refactor to use `IpAddr` instead of `Ipv4Addr` (2 hours)
  - Update scanner struct fields (`local_ip`, `target_ip`)
  - Update method signatures (send_syn, recv_responses)
  - Update connection tracking (replace `Ipv4Addr` keys with `IpAddr`)
  - Deliverable: `crates/prtip-scanner/src/syn_scanner.rs` (~100 lines modified)

- [ ] **Task 1.2:** Add IPv6 response parsing (1.5 hours)
  - Handle 40-byte IPv6 header (vs 20-byte IPv4)
  - Skip extension headers to find TCP header (Hop-by-Hop, Routing, Fragment, Destination Options)
  - Parse TCP flags from IPv6 packets (SYN-ACK, RST)
  - Deliverable: IPv6 response handler in syn_scanner.rs (~80 lines)

- [ ] **Task 1.3:** Implement dual-stack local IP management (1 hour)
  - Detect local IPv6 addresses (interface enumeration)
  - Select appropriate source IP per target (IPv4 → IPv4 source, IPv6 → IPv6 source)
  - Handle ICMPv6 errors (Type 1: Destination Unreachable)
  - Deliverable: Local IP selection logic (~40 lines)

- [ ] **Task 1.4:** Add 8+ integration tests (0.5 hours)
  - Test: IPv6 SYN scan (2001:db8::1)
  - Test: Dual-stack (both IPv4 and IPv6 targets)
  - Test: Response parsing (SYN-ACK, RST from IPv6)
  - Test: ICMPv6 error handling (Type 1 Code 1: admin prohibited)
  - Deliverable: `crates/prtip-scanner/tests/test_syn_scanner_ipv6.rs` (~150 lines)

**Technical Challenges:**
- Extension header traversal (multiple types, variable length)
- Fragment reassembly (IPv6 uses Fragment extension header, not IP header flags)
- ICMPv6 Type 1 Code 1 (communication administratively prohibited) detection

**Files to Modify:**
- `crates/prtip-scanner/src/syn_scanner.rs` (~100 lines)
- `crates/prtip-scanner/tests/test_syn_scanner_ipv6.rs` (NEW, ~150 lines)

#### Phase 2: UDP + Stealth Scanners IPv6 (8 hours)

**Objective:** Add IPv6 support to UDP and Stealth (FIN/NULL/Xmas/ACK) scanners.

**UDP Scanner IPv6 (4 hours):**

- [ ] **Task 2.1:** Add ICMPv6 Type 1 Code 4 handling (2 hours)
  - Parse ICMPv6 headers (Type 1: Destination Unreachable, Code 4: Port Unreachable)
  - Extract original packet from ICMPv6 payload (first 64 bits of original datagram)
  - Map ICMPv6 responses to scan results (closed port)
  - Deliverable: ICMPv6 handling in udp_scanner.rs (~60 lines)

- [ ] **Task 2.2:** Update connection tracking for dual-stack (1 hour)
  - Replace `Ipv4Addr` keys with `IpAddr` in tracking HashMap
  - Handle IPv4/IPv6 ICMP differently (Type 3 vs Type 1)
  - Deliverable: Dual-stack tracking (~30 lines)

- [ ] **Task 2.3:** Add 8+ integration tests (1 hour)
  - Test: IPv6 UDP scan (DNS port 53, SNMP port 161)
  - Test: ICMPv6 Type 1 Code 4 parsing
  - Test: Dual-stack UDP scanning
  - Deliverable: `crates/prtip-scanner/tests/test_udp_scanner_ipv6.rs` (~120 lines)

**Stealth Scanner IPv6 (4 hours):**

- [ ] **Task 2.4:** Add FIN/NULL/Xmas/ACK IPv6 variants (2 hours)
  - Update packet building for IPv6 (use Ipv6TcpPacketBuilder from Sprint 4.21)
  - Handle IPv6 responses (RST, no response patterns)
  - Support all 4 stealth modes with IPv6
  - Deliverable: IPv6 stealth modes in stealth_scanner.rs (~60 lines)

- [ ] **Task 2.5:** Update connection tracking (1 hour)
  - Replace `Ipv4Addr` with `IpAddr` in tracking structures
  - Handle IPv6 RST responses
  - Deliverable: Dual-stack tracking (~20 lines)

- [ ] **Task 2.6:** Add 8+ integration tests (1 hour)
  - Test: FIN scan IPv6
  - Test: NULL scan IPv6
  - Test: Xmas scan IPv6
  - Test: ACK scan IPv6 (firewall detection)
  - Deliverable: `crates/prtip-scanner/tests/test_stealth_scanner_ipv6.rs` (~120 lines)

**Technical Challenges:**
- ICMPv6 Type 1 has 6 codes (vs ICMP Type 3's 16 codes): Simplifies parsing
- IPv6 has no fragmentation in main header (uses extension headers): Different offset calculations
- TCP options parsing same for IPv4/IPv6: Offset differs due to IPv6 header size (40 vs 20 bytes)

**Files to Modify:**
- `crates/prtip-scanner/src/udp_scanner.rs` (~80 lines)
- `crates/prtip-scanner/src/stealth_scanner.rs` (~80 lines)
- `crates/prtip-scanner/tests/test_udp_scanner_ipv6.rs` (NEW, ~120 lines)
- `crates/prtip-scanner/tests/test_stealth_scanner_ipv6.rs` (NEW, ~120 lines)

#### Phase 3: Discovery + Decoy Scanners IPv6 (7 hours)

**Objective:** Add IPv6 support to Discovery and Decoy scanners.

**Discovery Engine IPv6 (4 hours):**

- [ ] **Task 3.1:** ICMPv6 Echo Request/Reply (2 hours)
  - Build ICMPv6 Echo Request (Type 128, Code 0) packets
  - Parse Echo Reply (Type 129, Code 0) responses
  - Handle timeouts (no response = host down or filtered)
  - Deliverable: ICMPv6 Echo in discovery.rs (~80 lines)

- [ ] **Task 3.2:** Neighbor Discovery Protocol (NDP) support (1 hour)
  - Implement Neighbor Solicitation (Type 135, Code 0)
  - Parse Neighbor Advertisement (Type 136, Code 0)
  - NDP replaces ARP for IPv6 (link-local discovery)
  - Deliverable: NDP support in discovery.rs (~60 lines)

- [ ] **Task 3.3:** Add 7+ integration tests (1 hour)
  - Test: ICMPv6 Echo Request/Reply (host discovery)
  - Test: NDP Neighbor Solicitation/Advertisement
  - Test: Dual-stack discovery (IPv4 ICMP + IPv6 ICMPv6)
  - Test: Timeouts and unreachable hosts
  - Deliverable: `crates/prtip-scanner/tests/test_discovery_ipv6.rs` (~140 lines)

**Decoy Scanner IPv6 (3 hours):**

- [ ] **Task 3.4:** Generate random IPv6 addresses in same /64 subnet (1.5 hours)
  - Extract target's /64 prefix (first 64 bits)
  - Randomize lower 64 bits (interface identifier)
  - Validate uniqueness (no duplicate decoys)
  - Ensure decoys are in same /64 to avoid routing issues
  - Deliverable: IPv6 decoy generation in decoy_scanner.rs (~50 lines)

- [ ] **Task 3.5:** Update packet building for IPv6 decoys (1 hour)
  - Use Ipv6TcpPacketBuilder with random source IPs
  - Maintain ME positioning (-D RND:5,ME syntax)
  - Support manual IPv6 decoys (-D 2001:db8::1,2001:db8::2,ME)
  - Deliverable: IPv6 packet building for decoys (~30 lines)

- [ ] **Task 3.6:** Add 7+ integration tests (0.5 hours)
  - Test: Random IPv6 decoy generation (RND:5)
  - Test: Manual IPv6 decoys (ip1,ip2,ME)
  - Test: /64 subnet validation
  - Deliverable: `crates/prtip-scanner/tests/test_decoy_scanner_ipv6.rs` (~100 lines)

**Technical Challenges:**
- NDP uses link-local addresses (fe80::/10): Requires interface-specific handling
- IPv6 /64 subnets are standard: 2^64 addresses = massive address space (vs IPv4 /24)
- Decoy addresses must be in same /64: Routing constraint for realistic decoy traffic

**Files to Modify:**
- `crates/prtip-scanner/src/discovery.rs` (~100 lines)
- `crates/prtip-scanner/src/decoy_scanner.rs` (~60 lines)
- `crates/prtip-scanner/tests/test_discovery_ipv6.rs` (NEW, ~140 lines)
- `crates/prtip-scanner/tests/test_decoy_scanner_ipv6.rs` (NEW, ~100 lines)

#### Phase 4: Integration + Documentation (5 hours)

**Objective:** CLI integration, comprehensive testing, and user documentation.

**CLI Integration (2 hours):**

- [ ] **Task 4.1:** Add `-6` flag: Force IPv6 only (0.5 hours)
  - Parse flag in args.rs
  - Filter targets to IPv6 addresses only
  - Error if no IPv6 targets provided
  - Deliverable: CLI flag in args.rs (~20 lines)

- [ ] **Task 4.2:** Add `-4` flag: Force IPv4 only (0.5 hours)
  - Parse flag in args.rs
  - Filter targets to IPv4 addresses only
  - Error if no IPv4 targets provided
  - Deliverable: CLI flag in args.rs (~20 lines)

- [ ] **Task 4.3:** Add `--dual-stack` flag: Scan both simultaneously (0.5 hours)
  - Enable parallel IPv4 and IPv6 scanning
  - Resolve hostnames to both A (IPv4) and AAAA (IPv6) records
  - Merge results from both address families
  - Deliverable: Dual-stack logic in main.rs (~40 lines)

- [ ] **Task 4.4:** Update help text and examples (0.5 hours)
  - Add IPv6 examples to --help output
  - Document -6, -4, --dual-stack flags
  - Deliverable: Help text updates (~30 lines)

**Cross-Scanner IPv6 Testing (2 hours):**

- [ ] **Task 4.5:** Combined IPv4/IPv6 tests (1 hour)
  - Test: Scan same target with IPv4 and IPv6 (dual-stack)
  - Test: Compare results (port states should match)
  - Test: Hostname resolution (A + AAAA records)
  - Test: Mixed target list (IPv4 + IPv6 + hostnames)
  - Test: Error handling (invalid IPv6 address format)
  - Deliverable: 5 integration tests in test_cli_args_ipv6.rs (~100 lines)

- [ ] **Task 4.6:** Dual-stack stress tests (0.5 hours)
  - Test: Large IPv6 range (2001:db8::1/64 - scan entire /64)
  - Test: Performance comparison (IPv4 vs IPv6 speed)
  - Test: Memory usage (IPv6 addresses are 128-bit vs 32-bit)
  - Deliverable: 3 stress tests (~60 lines)

- [ ] **Task 4.7:** Edge case tests (0.5 hours)
  - Test: Invalid IPv6 addresses (malformed, out of range)
  - Test: Unreachable IPv6 hosts (no route to host)
  - Test: ICMPv6 errors (Type 1 Code 0-5)
  - Test: Link-local addresses (fe80::/10)
  - Deliverable: 4 edge case tests (~80 lines)

**Documentation (1 hour):**

- [ ] **Task 4.8:** Create `docs/21-IPv6-GUIDE.md` (0.75 hours)
  - Section 1: IPv6 addressing fundamentals (128-bit, hex notation, /64 subnets)
  - Section 2: ProRT-IP IPv6 usage examples (all 6 scanner types)
  - Section 3: Performance considerations (header parsing overhead, /64 scan times)
  - Section 4: Troubleshooting (no route to host, NDP issues, link-local)
  - Deliverable: docs/21-IPv6-GUIDE.md (~800 lines)

- [ ] **Task 4.9:** Update README.md + CHANGELOG.md (0.25 hours)
  - README: Add "Complete IPv6 support" to features section
  - CHANGELOG: Add Sprint 5.1 section with all changes
  - Deliverable: +10 lines README, +60 lines CHANGELOG

**Files to Modify:**
- `crates/prtip-cli/src/args.rs` (+60 lines: -6, -4, --dual-stack flags)
- `crates/prtip-cli/src/main.rs` (+40 lines: dual-stack logic)
- `crates/prtip-cli/tests/test_cli_args_ipv6.rs` (NEW, ~240 lines: 12 tests)
- `docs/21-IPv6-GUIDE.md` (NEW, ~800 lines)
- `README.md` (+10 lines)
- `CHANGELOG.md` (+60 lines)

**Deliverables:**

1. **Code:**
   - `crates/prtip-scanner/src/syn_scanner.rs` (~100 lines modified, 8 tests)
   - `crates/prtip-scanner/src/udp_scanner.rs` (~80 lines modified, 8 tests)
   - `crates/prtip-scanner/src/stealth_scanner.rs` (~80 lines modified, 8 tests)
   - `crates/prtip-scanner/src/discovery.rs` (~100 lines modified, 7 tests)
   - `crates/prtip-scanner/src/decoy_scanner.rs` (~60 lines modified, 7 tests)
   - `crates/prtip-cli/src/args.rs` (+60 lines: CLI flags)
   - `crates/prtip-cli/src/main.rs` (+40 lines: dual-stack)
   - **Total:** ~520 lines production code

2. **Tests:**
   - Unit tests: 50+ new tests (8+8+8+7+7+12 = 50)
   - Integration tests: 12 cross-scanner tests
   - **Total:** 62 new tests
   - **Target Coverage:** 85%+ for new IPv6 code

3. **Documentation:**
   - `docs/21-IPv6-GUIDE.md` (800 lines: fundamentals, examples, troubleshooting)
   - README.md update (+10 lines)
   - CHANGELOG.md Sprint 5.1 entry (+60 lines)
   - **Total:** ~870 lines documentation

4. **Artifacts:**
   - Sprint completion report (performance benchmarks, test results)
   - IPv6 vs IPv4 speed comparison (target: ≥90% parity)

**Success Criteria:**

**Functional:**
- [ ] All 6 scanner types support IPv6: ✅ TCP Connect (done in 4.21), ✅ SYN, ✅ UDP, ✅ Stealth, ✅ Discovery, ✅ Decoy
- [ ] CLI flags working: -6 (IPv6 only), -4 (IPv4 only), --dual-stack (both)
- [ ] Dual-stack hostname resolution (A + AAAA records)
- [ ] ICMPv6 error handling (Type 1 Codes 0-5)

**Quality:**
- [ ] All tests passing: 1,338 → 1,400 (62 new tests, 0 regressions)
- [ ] Zero clippy warnings
- [ ] Coverage: 85%+ for new IPv6 code (measured by tarpaulin)
- [ ] Zero production panics in IPv6 paths

**Performance:**
- [ ] IPv6 scan speed ≥90% of IPv4 speed (measured by hyperfine)
  - Acceptable: 5.1ms IPv4 → 5.6ms IPv6 (10% overhead)
  - Target: 5.1ms IPv4 → 5.3ms IPv6 (4% overhead)
- [ ] Dual-stack scans <2x IPv4-only time (parallel scanning, not sequential)
- [ ] Memory usage <10% increase for IPv6 (128-bit addresses vs 32-bit)

**Documentation:**
- [ ] IPv6 guide complete with troubleshooting section
- [ ] All CLI flags documented in --help output
- [ ] Examples provided for all 6 scanner types + IPv6
- [ ] CHANGELOG Sprint 5.1 entry complete

**Testing Requirements:**
- **Unit Tests:** 50 minimum (target: 62 achieved)
- **Integration Tests:** 12 minimum (combined IPv4/IPv6, dual-stack, edge cases)
- **Performance Tests:** IPv4 vs IPv6 speed comparison (hyperfine benchmark)
- **Cross-Platform:** Linux, Windows, macOS validation (IPv6 stack differences)

**Dependencies & Prerequisites:**

**Requires Completed:**
- Sprint 4.21: IPv6 packet building infrastructure (✅ COMPLETE)
  - ipv6_packet.rs (671 lines, RFC 8200)
  - icmpv6.rs (556 lines, RFC 4443)
  - Ipv6TcpPacketBuilder, Ipv6UdpPacketBuilder
  - TCP Connect IPv6 support (reference implementation)

**Blocks:**
- Sprint 5.6: Code Coverage (benefits from 62 new tests)
- Sprint 5.7: Fuzz Testing (needs IPv6 parsers complete)
- Sprint 5.8: Plugin System (stable API requires IPv6 complete)

**External Dependencies:**
- No new crates required (foundation complete in 4.21)
- **System Requirements:**
  - IPv6 networking enabled on test systems
  - IPv6 connectivity for integration tests (local or internet)
  - ICMPv6 support (ping6 command working)

**Technical Design Notes:**

**High-Level Approach:**
1. **Refactor to IpAddr:** Replace `Ipv4Addr` with `IpAddr` enum throughout scanner code
2. **IPv6 Response Parsing:** Handle 40-byte fixed header + extension headers
3. **Dual-Stack Management:** Auto-detect local IPv4/IPv6, select source IP per target
4. **ICMPv6 Handling:** Map Type 1 codes to scan results (unreachable, admin prohibited, port unreachable)
5. **NDP for Discovery:** Implement Neighbor Solicitation/Advertisement (replaces ARP)

**Architecture Decisions:**
- **IpAddr Enum:** Standard library type supports both IPv4 and IPv6 (no custom types)
- **Extension Headers:** Skip to find TCP/UDP (don't parse all extension types in Phase 5)
- **Dual-Stack Default:** Resolve hostnames to both A and AAAA records (user can override with -4/-6)
- **Performance:** Use IPv6 packet builder from Sprint 4.21 (zero-copy compatible)

**Implementation Patterns:**
- Follow TCP Connect IPv6 pattern from Sprint 4.21b (proven reference)
- Reuse PacketBuffer infrastructure for zero-copy (no regression)
- Maintain timing templates (T0-T5) for IPv6 (same rate limiting)
- Preserve error handling patterns (circuit breaker, retry logic)

**Research References:**
- **RFC 8200:** IPv6 Specification (fixed 40-byte header, extension headers)
- **RFC 4443:** ICMPv6 for IPv6 (Type 1: Destination Unreachable, Type 128/129: Echo)
- **RFC 4861:** Neighbor Discovery for IPv6 (NDP replaces ARP)
- **Nmap IPv6 Support:** https://nmap.org/book/port-scanning-ipv6.html (feature parity reference)
- **pnet crate docs:** IPv6 packet parsing (etherparse alternative)

**Risk Mitigation:**

**Risk:** Sprint 5.1 exceeds 30 hours due to unforeseen IPv6 edge cases
- **Likelihood:** MEDIUM (large scope, 25-30h is aggressive)
- **Impact:** HIGH (delays all subsequent sprints on critical path)
- **Mitigation:**
  - Budget 35-40 hours contingency (1 extra week)
  - Defer Decoy IPv6 (Phase 3) if timeline slips (lower priority than SYN/UDP)
  - Leverage Sprint 4.21 foundation (30% complete reduces risk)

**Risk:** Performance regression >10% for IPv6 scanning
- **Likelihood:** LOW (header parsing is straightforward, no algorithm changes)
- **Impact:** MEDIUM (violates <10% overhead target)
- **Mitigation:**
  - Benchmark after Phase 1 (SYN scanner, early warning)
  - Profile with perf/flamegraph if regression detected
  - Optimize hot paths (extension header skipping)

**Risk:** ICMPv6 parsing bugs cause false positives/negatives
- **Likelihood:** MEDIUM (complex protocol, 6 Type 1 codes)
- **Impact:** HIGH (incorrect scan results undermine trust)
- **Mitigation:**
  - Comprehensive unit tests for all ICMPv6 codes (Phase 2, Task 2.3)
  - Integration tests with real ICMPv6 traffic (Phase 4, Task 4.7)
  - Reference Nmap behavior for ambiguous cases

**Open Questions:**
- [ ] Should --dual-stack be default behavior? (Or require explicit flag?)
  - **Recommendation:** Default to target type (IPv4 → IPv4, IPv6 → IPv6, hostname → A records only). Require --dual-stack for both.
- [ ] How to handle IPv6 /64 scans? (2^64 addresses = 18 quintillion)
  - **Recommendation:** Warn user if range >1M addresses. Suggest sampling or blacklist known-empty ranges.
- [ ] Should we support IPv6 fragmentation extension headers? (Type 44)
  - **Recommendation:** DEFER to Phase 6 (rare in practice, MTU discovery handles most cases).

---

### Sprint 5.2: Service Detection Enhancement

**Overview:**
- **Priority:** HIGH (quality improvement, quick win)
- **ROI Score:** HIGH (improves reconnaissance quality for all subsequent usage)
- **Duration:** 10-12 hours
- **Effort Breakdown:** 3h HTTP + 2h SSH + 3h SMB + 3h Database + 1h Tests
- **Dependencies:** NONE (independent of Sprint 5.1)
- **Risk Level:** LOW (proven patterns, small scope)
- **Strategic Value:** Increase detection rate from 70-80% to 85-90% (industry-leading). Better reconnaissance results for penetration testers.

**Rationale:**
Service detection enhancement follows IPv6 completion because:
1. Quick win (10-12h) boosts morale after large Sprint 5.1
2. No dependencies, can start immediately after 5.1
3. Improves reconnaissance quality for all future scanning
4. Proven patterns from Phase 3 (extend existing service_db.rs)
5. Sets quality standard before implementing complex features (Idle, Plugins)

Current detection rate (70-80%) is good but not excellent. Nmap achieves ~90% through extensive protocol-specific parsing. This sprint targets 85-90% by adding HTTP header analysis, SSH banner parsing, SMB dialect negotiation, and database handshakes—high-value protocols covering majority of remaining 10-20% gap.

**Objectives:**
1. Increase service detection rate from 70-80% to 85-90% (10-15 percentage point improvement)
2. Add HTTP header fingerprinting (Server, X-Powered-By, X-AspNet-Version)
3. Implement SSH banner regex matching (OpenSSH versions, key exchange)
4. Add SMB dialect negotiation (Windows version detection via SMB)
5. Implement database protocol handshakes (MySQL, PostgreSQL, MSSQL version detection)

**Tasks (Detailed 6-Phase Breakdown):**

#### Phase 1: Research & Design (2 hours)

- [ ] **Task 1.1:** Audit current service detection gaps (1 hour)
  - Review service_db.rs embedded probes (187 total)
  - Identify missing protocols in top 100 ports
  - Analyze false negative patterns from test corpus
  - Prioritize: HTTP (80/443), SSH (22), SMB (445), MySQL (3306), PostgreSQL (5432)
  - Deliverable: Gap analysis document (internal, 200 lines)

- [ ] **Task 1.2:** Research protocol specifications (1 hour)
  - HTTP headers: Server, X-Powered-By, X-AspNet-Version, Via
  - SSH banner format: "SSH-2.0-OpenSSH_X.Y" regex patterns
  - SMB dialect negotiation: SMB1/SMB2/SMB3 handshake differences
  - MySQL handshake: Server version packet (first 4 bytes)
  - PostgreSQL handshake: Startup message + parameter status
  - Deliverable: Protocol notes (internal, 150 lines)

#### Phase 2: Implementation - HTTP Fingerprinting (3 hours)

- [ ] **Task 2.1:** HTTP header parser enhancement (1.5 hours)
  - Parse Server header (e.g., "Apache/2.4.41 (Ubuntu)")
  - Parse X-Powered-By (e.g., "PHP/7.4.3", "ASP.NET")
  - Parse X-AspNet-Version (e.g., "4.0.30319")
  - Extract product name + version from headers
  - Map to CPE format (Common Platform Enumeration)
  - Deliverable: http_fingerprint.rs module (~150 lines)

- [ ] **Task 2.2:** Integrate with existing service detection (1 hour)
  - Update ServiceDetector to call http_fingerprint() for ports 80/443/8080/8443
  - Merge results with existing HTTP probe results
  - Prioritize header-based detection over banner grabbing (more reliable)
  - Deliverable: Integration in service_detector.rs (~40 lines)

- [ ] **Task 2.3:** Add 6 HTTP tests (0.5 hours)
  - Test: Apache/2.4 detection
  - Test: Nginx/1.18 detection
  - Test: IIS/10.0 detection (X-AspNet-Version)
  - Test: PHP detection (X-Powered-By)
  - Test: Express.js detection (X-Powered-By)
  - Test: Missing headers (graceful degradation)
  - Deliverable: tests/test_http_fingerprint.rs (~120 lines)

#### Phase 3: Implementation - SSH Banner Parsing (2 hours)

- [ ] **Task 3.1:** SSH banner regex engine (1 hour)
  - Parse SSH-2.0 protocol version
  - Extract server software (OpenSSH, Dropbear, libssh)
  - Extract version number (e.g., OpenSSH_8.2p1)
  - Extract OS hints (Ubuntu-4ubuntu0.3)
  - Map to structured format (product, version, OS)
  - Deliverable: ssh_banner.rs module (~100 lines)

- [ ] **Task 3.2:** Integrate with service detection (0.5 hours)
  - Update ServiceDetector for port 22
  - Call ssh_banner::parse() on banner responses
  - Merge with existing SSH probe results
  - Deliverable: Integration in service_detector.rs (~20 lines)

- [ ] **Task 3.3:** Add 4 SSH tests (0.5 hours)
  - Test: OpenSSH 8.2 detection
  - Test: Dropbear detection
  - Test: libssh detection
  - Test: Malformed banner (graceful error handling)
  - Deliverable: tests/test_ssh_banner.rs (~80 lines)

#### Phase 4: Implementation - SMB & Database Protocols (3 hours)

**SMB Dialect Negotiation (1.5 hours):**

- [ ] **Task 4.1:** SMB handshake builder (1 hour)
  - Build SMB Negotiate Protocol Request (SMB1/SMB2/SMB3)
  - Parse Negotiate Protocol Response (dialect, capabilities)
  - Extract Windows version from SMB2 response (NegotiateResponse.SystemTime)
  - Map dialect to Windows version (SMB1=XP/2003, SMB2=Vista/2008, SMB3=8/2012)
  - Deliverable: smb_handshake.rs module (~120 lines)

- [ ] **Task 4.2:** Add 3 SMB tests (0.5 hours)
  - Test: SMB1 (Windows XP/2003)
  - Test: SMB2 (Windows 7/2008 R2)
  - Test: SMB3 (Windows 10/2016)
  - Deliverable: tests/test_smb_handshake.rs (~60 lines)

**Database Protocol Handshakes (1.5 hours):**

- [ ] **Task 4.3:** MySQL handshake parser (0.75 hours)
  - Send: Empty packet to trigger handshake
  - Parse: Handshake packet (server version, protocol version, auth plugin)
  - Extract: MySQL version string (e.g., "5.7.33-0ubuntu0.18.04.1")
  - Deliverable: mysql_handshake.rs (~80 lines)

- [ ] **Task 4.4:** PostgreSQL handshake parser (0.5 hours)
  - Send: Startup message (protocol 3.0)
  - Parse: Authentication request + Parameter Status
  - Extract: PostgreSQL version from ParameterStatus (e.g., "12.5")
  - Deliverable: postgresql_handshake.rs (~60 lines)

- [ ] **Task 4.5:** Add 4 database tests (0.25 hours)
  - Test: MySQL 5.7 detection
  - Test: MySQL 8.0 detection
  - Test: PostgreSQL 12 detection
  - Test: Connection refused (graceful error)
  - Deliverable: tests/test_database_handshakes.rs (~80 lines)

#### Phase 5: Integration & Testing (1.5 hours)

- [ ] **Task 5.1:** Update service_db.rs for new protocols (0.5 hours)
  - Register HTTP fingerprinting for ports 80/443/8080/8443
  - Register SSH banner parsing for port 22
  - Register SMB handshake for port 445
  - Register MySQL handshake for port 3306
  - Register PostgreSQL handshake for port 5432
  - Deliverable: service_db.rs updates (~40 lines)

- [ ] **Task 5.2:** End-to-end integration tests (0.75 hours)
  - Test: Scan localhost with HTTP/SSH/SMB/MySQL/PostgreSQL services running
  - Verify: Detection rate ≥85% across all protocols
  - Compare: Results vs Nmap on same target (accuracy validation)
  - Deliverable: tests/test_enhanced_service_detection.rs (~150 lines)

- [ ] **Task 5.3:** Performance validation (0.25 hours)
  - Benchmark: Service detection overhead (should be <10%)
  - Compare: Sprint 5.1 baseline vs Sprint 5.2 with enhancements
  - Validate: No regression in scan speed
  - Deliverable: Hyperfine benchmark results

#### Phase 6: Documentation & Completion (1.5 hours)

- [ ] **Task 6.1:** Update service detection documentation (1 hour)
  - Update docs/07-SERVICE-DETECTION.md with new protocols
  - Add examples for HTTP/SSH/SMB/database detection
  - Document detection rate improvement (70% → 85-90%)
  - Deliverable: docs/07-SERVICE-DETECTION.md (+200 lines)

- [ ] **Task 6.2:** CHANGELOG and README updates (0.5 hours)
  - CHANGELOG: Sprint 5.2 entry with all enhancements
  - README: Update service detection section (85-90% rate)
  - Deliverable: CHANGELOG.md (+40 lines), README.md (+5 lines)

**Deliverables:**

1. **Code:**
   - `crates/prtip-scanner/src/detection/http_fingerprint.rs` (NEW, ~150 lines, 6 tests)
   - `crates/prtip-scanner/src/detection/ssh_banner.rs` (NEW, ~100 lines, 4 tests)
   - `crates/prtip-scanner/src/detection/smb_handshake.rs` (NEW, ~120 lines, 3 tests)
   - `crates/prtip-scanner/src/detection/mysql_handshake.rs` (NEW, ~80 lines, 2 tests)
   - `crates/prtip-scanner/src/detection/postgresql_handshake.rs` (NEW, ~60 lines, 2 tests)
   - `crates/prtip-scanner/src/service_detector.rs` (~100 lines modified)
   - `crates/prtip-scanner/src/service_db.rs` (~40 lines modified)
   - **Total:** ~650 lines production code

2. **Tests:**
   - Unit tests: 20 new tests (6 HTTP + 4 SSH + 3 SMB + 4 database + 3 integration)
   - Detection rate validation: Measure on test corpus
   - **Target Coverage:** 90%+ for new detection code

3. **Documentation:**
   - docs/07-SERVICE-DETECTION.md updated (+200 lines)
   - CHANGELOG.md Sprint 5.2 entry (+40 lines)
   - README.md service detection section (+5 lines)

4. **Artifacts:**
   - Detection rate comparison report (70-80% → 85-90%)
   - Protocol specification references (HTTP, SSH, SMB, MySQL, PostgreSQL)

**Success Criteria:**

**Functional:**
- [ ] HTTP header fingerprinting working (Server, X-Powered-By, X-AspNet-Version)
- [ ] SSH banner parsing extracting version + OS hints
- [ ] SMB dialect negotiation detecting Windows version
- [ ] MySQL/PostgreSQL handshakes extracting version strings
- [ ] Service detection rate ≥85% on test corpus (measured vs Nmap baseline)

**Quality:**
- [ ] All tests passing: 1,400 → 1,420 (20 new tests, 0 regressions)
- [ ] Zero clippy warnings
- [ ] Coverage: 90%+ for new detection modules
- [ ] Zero panics in protocol parsing (graceful error handling)

**Performance:**
- [ ] Service detection overhead <10% (HTTP parsing is fast)
- [ ] No scan speed regression vs Sprint 5.1
- [ ] <50ms per service probe (database handshakes are quick)

**Documentation:**
- [ ] Service detection guide updated with new protocols
- [ ] Examples provided for all 5 enhanced protocols
- [ ] Detection rate improvement documented (70% → 85-90%)

**Testing Requirements:**
- **Unit Tests:** 20 minimum (6+4+3+4+3)
- **Integration Tests:** 3 end-to-end (HTTP+SSH+SMB, databases, comparison vs Nmap)
- **Performance Tests:** Overhead measurement (<10% target)
- **Accuracy Tests:** Detection rate on 100+ service corpus (≥85% target)

**Dependencies & Prerequisites:**

**Requires Completed:**
- Sprint 5.1: IPv6 completion (✅ COMPLETE or in progress)
  - Reason: Enhanced service detection will work on IPv6 targets

**Blocks:**
- Sprint 5.6: Code Coverage (20 tests contribute to coverage improvement)
- Sprint 5.8: Plugin System (enhanced detection provides better baseline for plugin scripts)

**External Dependencies:**
- No new crates required (regex, nom already in dependencies from Phase 3)

**Technical Design Notes:**

**HTTP Fingerprinting:**
- Use existing HTTP parser from banner_grabber.rs (extend, don't rewrite)
- Parse response headers line-by-line (avoid buffering entire response)
- CPE format: `cpe:2.3:a:apache:http_server:2.4.41:*:*:*:*:*:*:*`

**SSH Banner Parsing:**
- Regex pattern: `SSH-(\d+\.\d+)-(\S+)_([\d\.]+)(.*)?`
- Capture groups: protocol, software, version, OS hint
- Example: "SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.3" → OpenSSH 8.2p1, Ubuntu

**SMB Dialect Negotiation:**
- Send all dialects (SMB1, SMB 2.002, SMB 2.1, SMB 3.0, SMB 3.02, SMB 3.11)
- Server responds with selected dialect (highest supported)
- Parse SystemTime field from SMB2 Negotiate Response (8 bytes, FILETIME format)
- Map dialect to Windows version (lookup table)

**Database Handshakes:**
- MySQL: Connect, read handshake packet (first packet server sends)
- PostgreSQL: Send StartupMessage, read AuthenticationRequest + ParameterStatus
- Extract version strings, map to product + version

**Research References:**
- **HTTP Headers:** RFC 7231 (HTTP/1.1), common non-standard headers
- **SSH Banner:** RFC 4253 Section 4.2 (SSH Protocol Version Exchange)
- **SMB Dialect:** MS-SMB2 specification (Negotiate Protocol)
- **MySQL Handshake:** MySQL Protocol Documentation (Connection Phase)
- **PostgreSQL Handshake:** PostgreSQL Frontend/Backend Protocol (Startup)

**Risk Mitigation:**

**Risk:** Detection rate <85% on test corpus
- **Likelihood:** LOW (targeted 5 high-value protocols cover most of remaining gap)
- **Impact:** MEDIUM (doesn't achieve success criteria)
- **Mitigation:**
  - Measure incrementally: HTTP (3%), SSH (2%), SMB (2%), Databases (3%) = 10% total gain
  - If <85%, add 2-3 more protocols (FTP, SMTP, RDP) in patch release

**Risk:** Protocol parsing bugs cause crashes
- **Likelihood:** MEDIUM (binary protocols, malformed responses)
- **Impact:** HIGH (undermines stability)
- **Mitigation:**
  - Comprehensive error handling (Result<T, E> for all parsers)
  - Fuzz testing in Sprint 5.7 will catch parser bugs
  - Unit tests with malformed input (Task 2.3, 3.3, 4.5)

**Open Questions:**
- [ ] Should we add HTTPS fingerprinting (TLS certificates)? (Or defer to Sprint 5.5?)
  - **Recommendation:** Defer to Sprint 5.5 (TLS Certificate Analysis). Focus 5.2 on application-layer protocols.
- [ ] How to handle version strings without CPE mapping?
  - **Recommendation:** Store raw version string, defer CPE mapping to v0.6.0 (requires CVE database).

---

### Sprint 5.3: Idle Scan Implementation

**Overview:**
- **Priority:** HIGH (critical Nmap feature gap, competitive parity)
- **ROI Score:** 8.3/10 (ENHANCEMENTS)
- **Duration:** 15-18 hours
- **Effort Breakdown:** 5h Zombie Discovery + 6h ISN Prediction + 4h Scan Logic + 3h Tests
- **Dependencies:** NONE (independent technique)
- **Risk Level:** LOW (well-documented in Nmap, proven technique)
- **Strategic Value:** Enables anonymity for red team operations. ProRT-IP achieves 100% Nmap core feature parity. Fills critical capability gap vs competitors (Masscan, RustScan, Naabu don't support idle scanning).

**Rationale:**
Idle scan (zombie scan) sequenced after service detection because:
1. Critical Nmap feature missing from v0.4.0 (competitive gap)
2. No dependencies (independent scanning technique)
3. Medium complexity (15-18h, well-documented in Salvatore Sanfilippo's paper)
4. High strategic value: Anonymity for penetration testers
5. Completing early achieves full Nmap parity before plugin system

Idle scanning uses a "zombie" host to scan targets without revealing scanner's IP. By measuring IPID (IP Identification field) increments on zombie, scanner infers whether target responded to spoofed SYN. Nmap's most sophisticated stealth technique, essential for attribution evasion in red team scenarios.

**Objectives:**
1. Implement zombie host discovery (find hosts with predictable IPID increments)
2. Create TCP ISN (Initial Sequence Number) prediction engine
3. Build idle scan port prober using SYN/ACK reflection technique
4. Add CLI flag `-sI <zombie_host>` for Nmap compatibility
5. Achieve 100% Nmap idle scan feature parity

**Tasks (Detailed 6-Phase Breakdown):**

#### Phase 1: Research & Design (2 hours)

- [ ] **Task 1.1:** Study Nmap idle scan implementation (1 hour)
  - Read Salvatore Sanfilippo's "Idle Scan" paper (original technique)
  - Analyze Nmap's ipid_scan.cc source code
  - Document IPID increment patterns (predictable vs random)
  - Understand zombie requirements (idle, no traffic, incremental IPID)
  - Deliverable: Design document (internal, 300 lines)

- [ ] **Task 1.2:** Design ProRT-IP idle scan architecture (1 hour)
  - Module structure: zombie_discovery.rs, ipid_tracker.rs, idle_scanner.rs
  - IPID measurement: SYN/ACK probes to zombie (measure baseline)
  - Port probing: Spoof SYN from zombie to target, measure IPID increment
  - Result interpretation: +0 (filtered), +1 (closed), +2 (open)
  - Deliverable: Architecture diagram + pseudocode (~200 lines)

#### Phase 2: Zombie Host Discovery (5 hours)

- [ ] **Task 2.1:** IPID increment detector (2 hours)
  - Send SYN/ACK probes to candidate zombie (trigger RST response)
  - Measure IPID in RST packets (3-5 probes, 1 second apart)
  - Calculate increment pattern: Sequential (+1 per probe), Random (varies), Grouped (per-host)
  - Classify: Good zombie (sequential), Bad zombie (random/grouped)
  - Deliverable: ipid_tracker.rs module (~180 lines)

- [ ] **Task 2.2:** Zombie discovery scanner (2 hours)
  - Scan subnet for potential zombies (common: printers, IoT devices, old servers)
  - Send SYN/ACK probes to each candidate
  - Filter: Keep hosts with sequential IPID increments
  - Rank: Lowest traffic zombies first (idle = predictable)
  - Deliverable: zombie_discovery.rs module (~200 lines)

- [ ] **Task 2.3:** Add 8 zombie discovery tests (1 hour)
  - Test: Sequential IPID detection (+1, +1, +1)
  - Test: Random IPID rejection (varies wildly)
  - Test: Grouped IPID rejection (per-host counter)
  - Test: Zombie ranking (prefer low traffic hosts)
  - Test: Discovery scan (find zombies in /24 subnet)
  - Test: No zombies found (error handling)
  - Test: Zombie goes offline mid-scan (fallback)
  - Test: Multiple zombie candidates (select best)
  - Deliverable: tests/test_zombie_discovery.rs (~180 lines)

#### Phase 3: ISN Prediction & IPID Correlation (6 hours)

- [ ] **Task 3.1:** Baseline IPID measurement (1.5 hours)
  - Measure zombie's IPID before port probe (baseline N)
  - Wait for target scan (SYN spoofed from zombie)
  - Measure zombie's IPID after port probe (baseline N+delta)
  - Calculate delta: +0 (no response), +1 (RST from target), +2 (SYN-ACK from target)
  - Deliverable: baseline_ipid() function in idle_scanner.rs (~80 lines)

- [ ] **Task 3.2:** Spoofed SYN packet builder (2 hours)
  - Build TCP SYN packet with spoofed source IP (zombie's IP)
  - Set destination: target IP + port
  - Calculate checksums (TCP + IP) for spoofed source
  - Send via raw socket (requires root/CAP_NET_RAW)
  - Deliverable: spoofed_syn() function in idle_scanner.rs (~100 lines)

- [ ] **Task 3.3:** IPID delta interpretation (1.5 hours)
  - Measure IPID delta: post_ipid - pre_ipid
  - Interpret results:
    - Delta = 0: Port filtered (no response reached zombie)
    - Delta = 1: Port closed (target sent RST to zombie)
    - Delta = 2: Port open (target sent SYN-ACK to zombie, zombie replied with RST)
  - Handle edge cases: Zombie traffic, IPID rollover (65535 → 0)
  - Deliverable: interpret_ipid_delta() function (~60 lines)

- [ ] **Task 3.4:** Add 10 ISN/IPID tests (1 hour)
  - Test: Baseline IPID measurement
  - Test: Spoofed SYN packet building
  - Test: Delta = 0 interpretation (filtered)
  - Test: Delta = 1 interpretation (closed)
  - Test: Delta = 2 interpretation (open)
  - Test: IPID rollover handling (65535 → 0)
  - Test: Zombie traffic noise (false increments)
  - Test: Timeout handling (zombie unresponsive)
  - Test: Target unresponsive (no delta)
  - Test: Invalid zombie IPID (non-sequential)
  - Deliverable: tests/test_idle_scan_logic.rs (~220 lines)

#### Phase 4: Idle Scanner Integration (4 hours)

- [ ] **Task 4.1:** Idle scanner main loop (2 hours)
  - For each target port:
    1. Measure baseline IPID from zombie
    2. Send spoofed SYN from zombie to target
    3. Wait for target to respond to zombie (100-500ms)
    4. Measure post-scan IPID from zombie
    5. Calculate delta and interpret result
  - Parallelize: Scan multiple ports concurrently (adaptive concurrency)
  - Deliverable: idle_scanner.rs main loop (~150 lines)

- [ ] **Task 4.2:** CLI integration (1 hour)
  - Add `-sI <zombie_host>` flag to args.rs
  - Parse zombie host (IP or hostname)
  - Validate zombie (run discovery check)
  - If valid, use IdleScanner; else error
  - Deliverable: args.rs + main.rs integration (~60 lines)

- [ ] **Task 4.3:** Add 7 integration tests (1 hour)
  - Test: Full idle scan workflow (zombie discovery → baseline → scan → interpret)
  - Test: Open port detection (delta = 2)
  - Test: Closed port detection (delta = 1)
  - Test: Filtered port detection (delta = 0)
  - Test: Multiple ports scanning
  - Test: Invalid zombie error handling
  - Test: CLI `-sI` flag parsing
  - Deliverable: tests/test_idle_scanner.rs (~180 lines)

#### Phase 5: Testing & Validation (2 hours)

- [ ] **Task 5.1:** End-to-end idle scan tests (1 hour)
  - Setup: Local test environment (zombie host + target host)
  - Test: Scan target via zombie, verify results match direct scan
  - Test: Compare results vs Nmap idle scan (accuracy validation)
  - Test: Performance: 1000 ports via idle scan (<5 minutes)
  - Deliverable: tests/test_idle_scan_e2e.rs (~150 lines)

- [ ] **Task 5.2:** Error handling and edge cases (1 hour)
  - Test: Zombie becomes active during scan (IPID becomes unpredictable)
  - Test: Target firewall blocks spoofed packets
  - Test: Zombie firewall blocks SYN/ACK probes
  - Test: Network congestion causes packet loss
  - Test: IPID exhaustion (65535 ports scanned, rollover)
  - Deliverable: tests/test_idle_scan_errors.rs (~120 lines)

#### Phase 6: Documentation & Completion (2 hours)

- [ ] **Task 6.1:** Create Idle Scan Guide (1.5 hours)
  - Section 1: Idle scan theory (zombie technique, IPID tracking)
  - Section 2: Zombie host requirements (idle, predictable IPID)
  - Section 3: Usage examples (zombie discovery, scanning via zombie)
  - Section 4: Troubleshooting (zombie goes active, firewall blocks, IPID rollover)
  - Section 5: Ethical considerations (attribution evasion, legal implications)
  - Deliverable: docs/22-IDLE-SCAN-GUIDE.md (~600 lines)

- [ ] **Task 6.2:** CHANGELOG and README updates (0.5 hours)
  - CHANGELOG: Sprint 5.3 entry with idle scan implementation
  - README: Add "-sI (Idle scan)" to scan types section
  - README: Note 100% Nmap core feature parity achieved
  - Deliverable: CHANGELOG.md (+50 lines), README.md (+10 lines)

**Deliverables:**

1. **Code:**
   - `crates/prtip-scanner/src/idle/zombie_discovery.rs` (NEW, ~200 lines, 8 tests)
   - `crates/prtip-scanner/src/idle/ipid_tracker.rs` (NEW, ~180 lines, included in zombie_discovery tests)
   - `crates/prtip-scanner/src/idle/idle_scanner.rs` (NEW, ~390 lines, 17 tests)
   - `crates/prtip-cli/src/args.rs` (~40 lines modified: -sI flag)
   - `crates/prtip-cli/src/main.rs` (~20 lines modified: idle scanner integration)
   - **Total:** ~770 lines production code

2. **Tests:**
   - Unit tests: 25 new tests (8 zombie + 10 ISN/IPID + 7 integration)
   - End-to-end tests: 2 comprehensive tests (5 scenarios each)
   - **Target Coverage:** 85%+ for idle scan modules

3. **Documentation:**
   - docs/22-IDLE-SCAN-GUIDE.md (NEW, ~600 lines: theory, usage, troubleshooting)
   - CHANGELOG.md Sprint 5.3 entry (+50 lines)
   - README.md scan types update (+10 lines)

4. **Artifacts:**
   - Sprint completion report (zombie discovery results, scan accuracy)
   - Comparison vs Nmap idle scan (accuracy validation)

**Success Criteria:**

**Functional:**
- [ ] Zombie discovery finds hosts with sequential IPID increments
- [ ] Idle scanner correctly identifies open/closed/filtered ports
- [ ] `-sI <zombie_host>` CLI flag working (Nmap compatibility)
- [ ] Accuracy: 100% match with Nmap idle scan on test corpus
- [ ] Performance: 1000 ports via idle scan <5 minutes

**Quality:**
- [ ] All tests passing: 1,420 → 1,445 (25 new tests, 0 regressions)
- [ ] Zero clippy warnings
- [ ] Coverage: 85%+ for idle scan modules
- [ ] Zero panics in idle scan paths (graceful error handling)

**Performance:**
- [ ] Zombie discovery: <10 seconds for /24 subnet
- [ ] Per-port probe: <3 seconds (100ms baseline + 500ms wait + 100ms post-scan)
- [ ] 1000 ports: <5 minutes (3s/port = 3000s / 60 = 50 minutes → parallelize 10x = 5 minutes)

**Documentation:**
- [ ] Idle scan guide complete with ethical considerations
- [ ] Usage examples for zombie discovery and scanning
- [ ] Troubleshooting section for common issues
- [ ] CHANGELOG entry documenting 100% Nmap parity

**Testing Requirements:**
- **Unit Tests:** 25 minimum (8 zombie + 10 ISN/IPID + 7 integration)
- **End-to-End Tests:** 2 comprehensive (10 scenarios total)
- **Accuracy Tests:** Compare vs Nmap idle scan (100% match target)
- **Performance Tests:** Zombie discovery (<10s), 1000 ports (<5 minutes)

**Dependencies & Prerequisites:**

**Requires Completed:**
- Phase 2 (TCP packet building): ✅ COMPLETE (Sprint 2.1)
- Raw socket support: ✅ COMPLETE (Phase 1)
- Privilege management: ✅ COMPLETE (Phase 1)

**Blocks:**
- Sprint 5.6: Code Coverage (25 tests contribute to coverage improvement)
- Sprint 5.8: Plugin System (stable idle scan API)

**External Dependencies:**
- No new crates required (pnet for raw sockets already in dependencies)

**Technical Design Notes:**

**Zombie Host Requirements:**
1. **Idle:** Minimal network traffic (predictable IPID)
2. **Sequential IPID:** Increments by 1 per packet (+1, +2, +3, ...)
3. **Reachable:** Responds to SYN/ACK probes (sends RST)
4. **No Firewall:** Allows outbound RST packets

**IPID Increment Patterns:**
- **Sequential:** Linux (kernel <4.18), old Windows (XP/2003) → Good zombie
- **Random:** Modern Linux (kernel 4.18+), modern Windows (10/Server 2016+) → Bad zombie
- **Grouped (per-host):** BSD systems → Bad zombie (separate counter per destination)

**Scan Workflow:**
```
1. Discover zombie: Scan subnet, find host with sequential IPID
2. Baseline: Measure zombie IPID (N)
3. Spoof SYN: Send SYN from zombie IP to target:port
4. Wait: 100-500ms for target to respond to zombie
5. Post-scan: Measure zombie IPID (N+delta)
6. Interpret:
   - delta=0: Filtered (target didn't respond to zombie)
   - delta=1: Closed (target sent RST to zombie)
   - delta=2: Open (target sent SYN-ACK to zombie, zombie replied with RST)
```

**Research References:**
- **Salvatore Sanfilippo's Idle Scan Paper:** Original technique description
- **Nmap Idle Scan:** https://nmap.org/book/idlescan.html
- **RFC 791 (IP):** IPID field specification (16-bit identification)
- **RFC 793 (TCP):** SYN/SYN-ACK/RST handshake

**Risk Mitigation:**

**Risk:** Zombie host goes active during scan (IPID becomes unpredictable)
- **Likelihood:** MEDIUM (depends on network environment)
- **Impact:** HIGH (scan results invalid)
- **Mitigation:**
  - Monitor zombie IPID between probes (detect anomalies)
  - If delta >2 unexpectedly, abort scan and find new zombie
  - Recommend scanning during low-traffic hours

**Risk:** Modern systems use random IPID (no suitable zombies)
- **Likelihood:** HIGH (Windows 10+, Linux 4.18+ default to random)
- **Impact:** MEDIUM (idle scan unavailable)
- **Mitigation:**
  - Document zombie requirements in guide
  - Provide alternative: Use VPS as controlled zombie (ethical concerns)
  - Suggest legacy systems as zombies (printers, IoT, old servers)

**Risk:** Firewall blocks spoofed packets (idle scan fails)
- **Likelihood:** MEDIUM (egress filtering common in enterprises)
- **Impact:** MEDIUM (idle scan unavailable)
- **Mitigation:**
  - Test zombie reachability before full scan
  - Error message: "Zombie unreachable or firewall blocking spoofed packets"
  - Suggest alternative scan type (SYN, stealth)

**Open Questions:**
- [ ] Should we support IPv6 idle scanning? (IPID equivalent: Flow Label)
  - **Recommendation:** DEFER to Phase 6. IPv6 uses Flow Label (20-bit) instead of IPID. Different technique.
- [ ] How to handle IPID rollover during large port scans? (65535 ports)
  - **Recommendation:** Track rollover count. If IPID wraps (65535→0), increment rollover counter and adjust delta calculation.

---

### Sprint 5.4: Advanced Rate Limiting

**Overview:**
- **Priority:** MEDIUM (operational improvement, enhances existing capability)
- **ROI Score:** MEDIUM-HIGH
- **Duration:** 12-15 hours
- **Effort Breakdown:** 4h ICMP Detection + 5h Token Bucket + 3h Integration + 2h Tests
- **Dependencies:** NONE (enhances existing rate limiter from Sprint 2.3)
- **Risk Level:** LOW (proven patterns, extends existing code)
- **Strategic Value:** Automatic adaptive throttling reduces manual tuning (--max-rate, timing templates). Better stealth through ICMP error detection. Improved reliability on rate-limited networks.

**Rationale:**
Advanced rate limiting follows idle scan because:
1. Builds on existing rate limiter from Phase 2 (Sprint 2.3)
2. Operational improvement for all subsequent sprints (better scanning experience)
3. Medium complexity (12-15h), proven patterns (token bucket, AIMD)
4. Enhances stealth and reliability (detects rate-limiting, adjusts automatically)
5. Quick win before quality foundation sprints (5.6, 5.7)

Current rate limiter uses timing templates (T0-T5) and manual flags (--max-rate, --min-rate). This works but requires user expertise. Advanced rate limiting adds automatic detection of ICMP rate-limit errors (Type 3 Code 13) and per-target adaptive throttling, reducing manual configuration while improving stealth.

**Objectives:**
1. Implement ICMP Type 3 Code 13 detection (Communication Administratively Prohibited)
2. Add per-target token bucket algorithm (separate limits per IP)
3. Create exponential backoff on consecutive rate-limit errors
4. Add CLI flags (--adaptive-rate, --rate-limit-threshold)
5. Maintain <5% performance overhead for adaptive rate limiting

**Tasks (Detailed 6-Phase Breakdown):**

#### Phase 1: Research & Design (2 hours)

- [ ] **Task 1.1:** Audit existing rate limiter (1 hour)
  - Review rate_limiter.rs from Sprint 2.3 (422 lines, token bucket + AIMD)
  - Identify enhancement points: ICMP detection, per-target tracking, exponential backoff
  - Analyze ICMP Type 3 Code 13 frequency in production scans
  - Deliverable: Enhancement plan document (internal, 200 lines)

- [ ] **Task 1.2:** Design adaptive rate limiter architecture (1 hour)
  - Module structure: icmp_monitor.rs, per_target_limiter.rs, adaptive_controller.rs
  - ICMP detection: Parse ICMP Type 3 Code 13 from responses
  - Per-target limits: HashMap<IpAddr, TokenBucket> (separate bucket per target)
  - Exponential backoff: 1x → 2x → 4x → 8x delay on consecutive errors
  - Deliverable: Architecture diagram + pseudocode (~250 lines)

#### Phase 2: ICMP Error Detection (4 hours)

- [ ] **Task 2.1:** ICMP Type 3 parser enhancement (2 hours)
  - Parse ICMP Destination Unreachable (Type 3)
  - Identify Code 13 (Communication Administratively Prohibited by Filtering)
  - Extract original packet from ICMP payload (first 64 bits of original datagram)
  - Map to target IP + port (from original TCP/UDP header)
  - Deliverable: icmp_monitor.rs module (~180 lines)

- [ ] **Task 2.2:** Rate-limit error aggregator (1.5 hours)
  - Track ICMP Type 3 Code 13 per target IP
  - Count consecutive errors (3+ = rate-limited)
  - Emit RateLimitDetected event to adaptive controller
  - Reset counter on successful response (target no longer rate-limited)
  - Deliverable: RateLimitAggregator in icmp_monitor.rs (~100 lines)

- [ ] **Task 2.3:** Add 6 ICMP detection tests (0.5 hours)
  - Test: ICMP Type 3 Code 13 parsing
  - Test: Original packet extraction
  - Test: Target IP mapping
  - Test: Consecutive error counting (1, 2, 3+ errors)
  - Test: Reset on success
  - Test: Ignore non-rate-limit ICMP (Code 0-12, 14-15)
  - Deliverable: tests/test_icmp_monitor.rs (~120 lines)

#### Phase 3: Per-Target Token Bucket (5 hours)

- [ ] **Task 3.1:** Per-target token bucket structure (2 hours)
  - Create HashMap<IpAddr, TokenBucket> for per-target limits
  - Initialize with global rate (from timing template or --max-rate)
  - Degrade on RateLimitDetected event (halve rate)
  - Restore gradually (double rate every 30s if no errors)
  - Deliverable: per_target_limiter.rs module (~200 lines)

- [ ] **Task 3.2:** Exponential backoff controller (2 hours)
  - Track consecutive rate-limit errors per target
  - Apply exponential backoff: 1x → 2x → 4x → 8x delay
  - Max backoff: 8x (prevent indefinite slowdown)
  - Reset on successful response
  - Integrate with timing templates (T0-T5 as base delay)
  - Deliverable: adaptive_controller.rs module (~180 lines)

- [ ] **Task 3.3:** Add 6 token bucket tests (1 hour)
  - Test: Per-target initialization (separate buckets)
  - Test: Degrade on rate-limit error (halve rate)
  - Test: Exponential backoff (1x → 2x → 4x → 8x)
  - Test: Max backoff cap (8x)
  - Test: Restore on success (double rate every 30s)
  - Test: Multiple targets (independent throttling)
  - Deliverable: tests/test_per_target_limiter.rs (~140 lines)

#### Phase 4: Integration & CLI (3 hours)

- [ ] **Task 4.1:** Integrate with scanner pipeline (1.5 hours)
  - Update scheduler.rs to use PerTargetLimiter
  - Replace global rate limiter with per-target limiter
  - Pass ICMP errors to IcmpMonitor
  - Apply adaptive backoff on RateLimitDetected events
  - Deliverable: scheduler.rs integration (~80 lines)

- [ ] **Task 4.2:** Add CLI flags (1 hour)
  - `--adaptive-rate`: Enable adaptive rate limiting (default: off for backward compatibility)
  - `--rate-limit-threshold N`: Consecutive ICMP errors before throttling (default: 3)
  - `--backoff-max N`: Max backoff multiplier (default: 8x)
  - Update help text with examples
  - Deliverable: args.rs + help text (~60 lines)

- [ ] **Task 4.3:** Add 6 integration tests (0.5 hours)
  - Test: Adaptive rate limiting enabled (--adaptive-rate)
  - Test: Rate-limit threshold (--rate-limit-threshold 5)
  - Test: Max backoff (--backoff-max 16)
  - Test: ICMP detection triggers throttling
  - Test: Recovery after successful responses
  - Test: Per-target independence (target A throttled, target B full speed)
  - Deliverable: tests/test_adaptive_rate_cli.rs (~120 lines)

#### Phase 5: Testing & Validation (2 hours)

- [ ] **Task 5.1:** End-to-end adaptive rate tests (1 hour)
  - Setup: Simulate rate-limited target (iptables ICMP Type 3 Code 13 injection)
  - Test: Scanner detects rate-limiting and throttles
  - Test: Exponential backoff applied (1x → 2x → 4x → 8x)
  - Test: Recovery when rate-limit lifted
  - Test: Performance overhead <5% (vs non-adaptive)
  - Deliverable: tests/test_adaptive_rate_e2e.rs (~150 lines)

- [ ] **Task 5.2:** Performance benchmarking (1 hour)
  - Benchmark: Scan 10,000 ports with adaptive rate vs without
  - Measure: Overhead (should be <5%)
  - Measure: CPU usage (token bucket operations)
  - Validate: No memory leaks (per-target HashMap size)
  - Deliverable: Hyperfine benchmark results

#### Phase 6: Documentation & Completion (1.5 hours)

- [ ] **Task 6.1:** Update rate limiting documentation (1 hour)
  - Update docs/11-RATE-LIMITING.md with adaptive features
  - Add examples for --adaptive-rate usage
  - Document ICMP Type 3 Code 13 detection
  - Explain exponential backoff algorithm
  - Deliverable: docs/11-RATE-LIMITING.md (+150 lines)

- [ ] **Task 6.2:** CHANGELOG and README updates (0.5 hours)
  - CHANGELOG: Sprint 5.4 entry with adaptive rate limiting
  - README: Update rate limiting section (mention --adaptive-rate)
  - Deliverable: CHANGELOG.md (+40 lines), README.md (+5 lines)

**Deliverables:**

1. **Code:**
   - `crates/prtip-scanner/src/rate_limiter/icmp_monitor.rs` (NEW, ~280 lines, 6 tests)
   - `crates/prtip-scanner/src/rate_limiter/per_target_limiter.rs` (NEW, ~200 lines, 6 tests)
   - `crates/prtip-scanner/src/rate_limiter/adaptive_controller.rs` (NEW, ~180 lines, included in per_target tests)
   - `crates/prtip-scanner/src/scheduler.rs` (~80 lines modified)
   - `crates/prtip-cli/src/args.rs` (~60 lines modified: CLI flags)
   - **Total:** ~660 lines production code

2. **Tests:**
   - Unit tests: 18 new tests (6 ICMP + 6 token bucket + 6 integration)
   - End-to-end tests: 2 comprehensive (adaptive rate scenarios)
   - **Target Coverage:** 85%+ for rate limiting modules

3. **Documentation:**
   - docs/11-RATE-LIMITING.md updated (+150 lines)
   - CHANGELOG.md Sprint 5.4 entry (+40 lines)
   - README.md rate limiting section (+5 lines)

4. **Artifacts:**
   - Performance benchmarks (adaptive vs non-adaptive overhead)
   - ICMP Type 3 Code 13 detection report

**Success Criteria:**

**Functional:**
- [ ] ICMP Type 3 Code 13 detection working (rate-limit errors identified)
- [ ] Per-target token bucket (independent throttling per IP)
- [ ] Exponential backoff (1x → 2x → 4x → 8x on consecutive errors)
- [ ] CLI flags working (--adaptive-rate, --rate-limit-threshold, --backoff-max)
- [ ] Automatic throttling reduces false negatives on rate-limited networks

**Quality:**
- [ ] All tests passing: 1,445 → 1,463 (18 new tests, 0 regressions)
- [ ] Zero clippy warnings
- [ ] Coverage: 85%+ for rate limiting modules
- [ ] Zero panics in rate limiting paths

**Performance:**
- [ ] Adaptive rate overhead <5% (measured by hyperfine)
- [ ] Per-target HashMap operations <1% CPU (low overhead)
- [ ] Memory usage <10MB for 10,000 targets (reasonable HashMap size)

**Documentation:**
- [ ] Rate limiting guide updated with adaptive features
- [ ] Examples provided for --adaptive-rate usage
- [ ] ICMP detection explained
- [ ] CHANGELOG entry complete

**Testing Requirements:**
- **Unit Tests:** 18 minimum (6+6+6)
- **End-to-End Tests:** 2 comprehensive (adaptive rate scenarios)
- **Performance Tests:** Overhead measurement (<5% target)
- **Stress Tests:** 10,000 targets (memory usage validation)

**Dependencies & Prerequisites:**

**Requires Completed:**
- Sprint 2.3: Rate limiter foundation (✅ COMPLETE, 422 lines)

**Blocks:**
- Sprint 5.6: Code Coverage (18 tests contribute)
- Sprint 5.8: Plugin System (stable rate limiting API)

**External Dependencies:**
- No new crates required (existing rate_limiter.rs has token bucket)

**Technical Design Notes:**

**ICMP Type 3 Code 13 Detection:**
- Parse ICMP header (8 bytes): Type (1 byte), Code (1 byte), Checksum (2 bytes), Unused (4 bytes)
- Extract original IP header + 64 bits of original data from ICMP payload
- Map to target IP from original IP header destination field
- Map to port from original TCP/UDP header (first 4 bytes: src port 16-bit, dst port 16-bit)

**Per-Target Token Bucket:**
- HashMap<IpAddr, TokenBucket> stores separate bucket per target
- Initialize with global rate (from --max-rate or timing template)
- On RateLimitDetected: Halve bucket refill rate (degrade)
- On Success: Double bucket refill rate every 30s (restore, max = global rate)
- Exponential backoff: Multiply delay by 2^errors (cap at 8x)

**Exponential Backoff Algorithm:**
```rust
fn calculate_delay(base_delay: Duration, consecutive_errors: u32, max_multiplier: u32) -> Duration {
    let multiplier = 2u32.pow(consecutive_errors).min(max_multiplier);
    base_delay * multiplier
}
```

**Research References:**
- **RFC 792 (ICMP):** Type 3 Code 13 specification
- **Token Bucket Algorithm:** Wikipedia, classic rate limiting algorithm
- **AIMD (Additive Increase Multiplicative Decrease):** TCP congestion control pattern

**Risk Mitigation:**

**Risk:** False positives (non-rate-limit ICMP errors trigger throttling)
- **Likelihood:** LOW (Code 13 is specific to admin filtering)
- **Impact:** MEDIUM (unnecessary throttling, slower scans)
- **Mitigation:**
  - Only trigger on Code 13 (ignore Codes 0-12, 14-15)
  - Require 3+ consecutive errors (--rate-limit-threshold)
  - User can disable with --adaptive-rate=false

**Risk:** Performance overhead from per-target HashMap
- **Likelihood:** LOW (HashMap lookups are O(1) average)
- **Impact:** MEDIUM (could slow scanning if overhead >5%)
- **Mitigation:**
  - Benchmark during Sprint 5.4 Phase 5
  - Use efficient hash function (FxHashMap from rustc-hash)
  - Prune old entries (remove targets after scan complete)

**Open Questions:**
- [ ] Should adaptive rate be default in v0.6.0? (Or keep opt-in?)
  - **Recommendation:** Keep opt-in for v0.5.0 (backward compatibility). Consider default in v1.0.
- [ ] How to handle IPv6 ICMP errors? (ICMPv6 Type 1 Code 1)
  - **Recommendation:** Extend icmp_monitor.rs to handle ICMPv6 in Sprint 5.1 follow-up.

---

### Sprint 5.5: TLS Certificate Analysis

**Overview:**
- **Priority:** MEDIUM (security auditing, enhances service detection)
- **ROI Score:** MEDIUM-HIGH
- **Duration:** 10-12 hours
- **Effort Breakdown:** 3h Chain Validation + 3h Weak Cipher + 2h Protocol Downgrade + 2h Integration + 2h Tests
- **Dependencies:** Sprint 5.2 (Service Detection, soft dependency)
- **Risk Level:** LOW (rustls integration straightforward)
- **Strategic Value:** Enables security auditing use case. Detects weak ciphers (RC4, 3DES, export), protocol downgrades (SSLv3, TLS 1.0), expired certificates. Differentiates ProRT-IP from speed-focused scanners (Masscan, ZMap).

**Rationale:**
TLS certificate analysis follows rate limiting because:
1. Enhances service detection from Sprint 5.2 (TLS-wrapped services)
2. Quick win (10-12h), proven patterns (rustls library)
3. Security auditing capability (weak cipher detection, certificate validation)
4. Sets foundation before quality sprints (5.6, 5.7)
5. Demonstrates ProRT-IP isn't just speed, also depth

Sprint 4.15 added basic TLS handshake (CN, SAN, issuer, expiry). This sprint extends to deep analysis: certificate chain validation, weak cipher detection (RC4, 3DES, export ciphers), protocol downgrade detection (SSLv3, TLS 1.0), OCSP stapling validation. Targets security-conscious users (compliance teams, pen testers auditing SSL/TLS configurations).

**Objectives:**
1. Implement certificate chain validation (root CA, intermediate, leaf)
2. Add weak cipher detection (RC4, 3DES, export ciphers, anonymous ciphers)
3. Create protocol downgrade detection (SSLv3, TLS 1.0, TLS 1.1)
4. Add OCSP stapling validation (check revocation status)
5. Add CLI flag `--tls-analysis` for deep HTTPS inspection

**Tasks (Detailed 6-Phase Breakdown):**

#### Phase 1: Research & Design (2 hours)

- [ ] **Task 1.1:** Audit existing TLS module (1 hour)
  - Review tls_handshake.rs from Sprint 4.15 (550 lines, 12 tests)
  - Identify enhancement points: chain validation, weak ciphers, protocol versions
  - Research rustls capabilities (certificate validation, cipher suite analysis)
  - Deliverable: Enhancement plan document (internal, 200 lines)

- [ ] **Task 1.2:** Design TLS analyzer architecture (1 hour)
  - Module structure: tls_chain_validator.rs, tls_cipher_analyzer.rs, tls_protocol_checker.rs
  - Chain validation: rustls WebPkiVerifier for root CA validation
  - Weak cipher detection: Maintain blacklist (RC4, 3DES, export, anonymous)
  - Protocol downgrade: Check ClientHello supported versions, server selection
  - Deliverable: Architecture diagram + pseudocode (~250 lines)

#### Phase 2: Certificate Chain Validation (3 hours)

- [ ] **Task 2.1:** Root CA validation (1.5 hours)
  - Use rustls WebPkiVerifier with system root store (webpki-roots crate)
  - Validate certificate chain: leaf → intermediate → root CA
  - Check: Certificate signatures, validity dates, key usage extensions
  - Report: Valid/Invalid, reason (expired, untrusted CA, self-signed)
  - Deliverable: tls_chain_validator.rs module (~180 lines)

- [ ] **Task 2.2:** Certificate chain parser (1 hour)
  - Extract certificates from TLS handshake (Certificate message)
  - Parse X.509 certificates (use x509-parser crate)
  - Build chain: leaf.issuer → intermediate.subject, intermediate.issuer → root.subject
  - Validate: Each certificate in chain
  - Deliverable: Chain parsing logic in tls_chain_validator.rs (~80 lines)

- [ ] **Task 2.3:** Add 5 chain validation tests (0.5 hours)
  - Test: Valid chain (trusted root CA)
  - Test: Self-signed certificate (untrusted)
  - Test: Expired certificate
  - Test: Untrusted CA (not in root store)
  - Test: Incomplete chain (missing intermediate)
  - Deliverable: tests/test_tls_chain_validator.rs (~100 lines)

#### Phase 3: Weak Cipher Detection (3 hours)

- [ ] **Task 3.1:** Cipher suite blacklist (1 hour)
  - Define weak ciphers: RC4, 3DES, export ciphers (40-bit, 56-bit), anonymous (no auth)
  - Create blacklist: TLS_RSA_WITH_RC4_128_SHA, TLS_RSA_WITH_3DES_EDE_CBC_SHA, etc.
  - Map cipher suite IDs to names (IANA registry)
  - Deliverable: WEAK_CIPHERS constant in tls_cipher_analyzer.rs (~100 lines)

- [ ] **Task 3.2:** Cipher suite analyzer (1.5 hours)
  - Parse ServerHello cipher suite selection
  - Check against blacklist (weak cipher detected?)
  - Extract: Key exchange (RSA, ECDHE), auth (RSA, ECDSA), encryption (AES, RC4), MAC (SHA, SHA256)
  - Report: Cipher suite name, weakness (weak key exchange, weak encryption, weak MAC)
  - Deliverable: analyze_cipher_suite() in tls_cipher_analyzer.rs (~120 lines)

- [ ] **Task 3.3:** Add 5 weak cipher tests (0.5 hours)
  - Test: RC4 detection (TLS_RSA_WITH_RC4_128_SHA)
  - Test: 3DES detection (TLS_RSA_WITH_3DES_EDE_CBC_SHA)
  - Test: Export cipher detection (TLS_RSA_EXPORT_WITH_RC4_40_MD5)
  - Test: Anonymous cipher detection (TLS_DH_anon_WITH_AES_128_CBC_SHA)
  - Test: Strong cipher (TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384)
  - Deliverable: tests/test_tls_cipher_analyzer.rs (~100 lines)

#### Phase 4: Protocol Downgrade Detection (2 hours)

- [ ] **Task 4.1:** Protocol version checker (1 hour)
  - Parse ClientHello supported versions (TLS 1.0, 1.1, 1.2, 1.3)
  - Parse ServerHello selected version
  - Check: Server selected weakest offered version? (possible downgrade attack)
  - Report: Protocol version, downgrade detected (yes/no)
  - Deliverable: tls_protocol_checker.rs module (~100 lines)

- [ ] **Task 4.2:** Deprecated protocol warnings (0.5 hours)
  - Flag SSLv3 (POODLE vulnerability, deprecated 2015)
  - Flag TLS 1.0 (deprecated 2020, BEAST vulnerability)
  - Flag TLS 1.1 (deprecated 2020, weak ciphers)
  - Recommend TLS 1.2+ (industry standard)
  - Deliverable: Deprecation warnings in tls_protocol_checker.rs (~40 lines)

- [ ] **Task 4.3:** Add 5 protocol tests (0.5 hours)
  - Test: SSLv3 detection (deprecated)
  - Test: TLS 1.0 detection (deprecated)
  - Test: TLS 1.1 detection (deprecated)
  - Test: TLS 1.2 (acceptable)
  - Test: TLS 1.3 (recommended)
  - Deliverable: tests/test_tls_protocol_checker.rs (~100 lines)

#### Phase 5: Integration & CLI (2 hours)

- [ ] **Task 5.1:** Integrate with service detection (1 hour)
  - Update ServiceDetector to call TLS analyzer for HTTPS ports (443, 8443)
  - Merge results: Basic handshake (4.15) + deep analysis (5.5)
  - Store: Chain validation, weak ciphers, protocol version in scan results
  - Deliverable: Integration in service_detector.rs (~60 lines)

- [ ] **Task 5.2:** Add `--tls-analysis` CLI flag (0.5 hours)
  - Enable deep TLS analysis (off by default for performance)
  - When enabled: Validate chains, check ciphers, check protocols
  - Output: TLS analysis report in scan results
  - Deliverable: args.rs + main.rs (~40 lines)

- [ ] **Task 5.3:** Add 5 integration tests (0.5 hours)
  - Test: `--tls-analysis` flag enables deep analysis
  - Test: Weak cipher detected in scan results
  - Test: Deprecated protocol flagged
  - Test: Valid chain reported
  - Test: Performance overhead <10%
  - Deliverable: tests/test_tls_analysis_cli.rs (~100 lines)

#### Phase 6: Documentation & Completion (1.5 hours)

- [ ] **Task 6.1:** Create TLS Analysis Guide (1 hour)
  - Section 1: TLS/SSL overview (handshake, certificates, cipher suites)
  - Section 2: ProRT-IP TLS analysis features
  - Section 3: Weak cipher detection (RC4, 3DES, export)
  - Section 4: Protocol downgrade detection (SSLv3, TLS 1.0)
  - Section 5: Usage examples (--tls-analysis flag)
  - Deliverable: docs/23-TLS-ANALYSIS-GUIDE.md (~400 lines)

- [ ] **Task 6.2:** CHANGELOG and README updates (0.5 hours)
  - CHANGELOG: Sprint 5.5 entry with TLS analysis
  - README: Add "--tls-analysis (Deep HTTPS inspection)" to features
  - Deliverable: CHANGELOG.md (+40 lines), README.md (+5 lines)

**Deliverables:**

1. **Code:**
   - `crates/prtip-scanner/src/detection/tls_chain_validator.rs` (NEW, ~260 lines, 5 tests)
   - `crates/prtip-scanner/src/detection/tls_cipher_analyzer.rs` (NEW, ~220 lines, 5 tests)
   - `crates/prtip-scanner/src/detection/tls_protocol_checker.rs` (NEW, ~140 lines, 5 tests)
   - `crates/prtip-scanner/src/service_detector.rs` (~60 lines modified)
   - `crates/prtip-cli/src/args.rs` (~40 lines modified: --tls-analysis flag)
   - **Total:** ~620 lines production code

2. **Tests:**
   - Unit tests: 15 new tests (5+5+5)
   - Integration tests: 5 comprehensive (TLS analysis scenarios)
   - **Target Coverage:** 85%+ for TLS analysis modules

3. **Documentation:**
   - docs/23-TLS-ANALYSIS-GUIDE.md (NEW, ~400 lines)
   - CHANGELOG.md Sprint 5.5 entry (+40 lines)
   - README.md TLS analysis section (+5 lines)

4. **Artifacts:**
   - Weak cipher blacklist (RC4, 3DES, export, anonymous)
   - Protocol version deprecation report

**Success Criteria:**

**Functional:**
- [ ] Certificate chain validation working (trusted root CA check)
- [ ] Weak cipher detection (RC4, 3DES, export, anonymous)
- [ ] Protocol downgrade detection (SSLv3, TLS 1.0, TLS 1.1)
- [ ] `--tls-analysis` CLI flag enabling deep inspection
- [ ] TLS analysis report in scan results

**Quality:**
- [ ] All tests passing: 1,463 → 1,478 (15 new tests, 0 regressions)
- [ ] Zero clippy warnings
- [ ] Coverage: 85%+ for TLS analysis modules
- [ ] Zero panics in TLS analysis paths

**Performance:**
- [ ] TLS analysis overhead <10% (when --tls-analysis enabled)
- [ ] No overhead when --tls-analysis disabled (opt-in)
- [ ] <100ms per HTTPS service analyzed

**Documentation:**
- [ ] TLS analysis guide complete
- [ ] Weak cipher blacklist documented
- [ ] Protocol deprecation rationale explained
- [ ] CHANGELOG entry complete

**Testing Requirements:**
- **Unit Tests:** 15 minimum (5+5+5)
- **Integration Tests:** 5 comprehensive (TLS analysis scenarios)
- **Performance Tests:** Overhead measurement (<10% target when enabled)
- **Cross-Platform:** Validate on Linux, Windows, macOS (different root stores)

**Dependencies & Prerequisites:**

**Requires Completed:**
- Sprint 4.15: TLS handshake foundation (✅ COMPLETE, 550 lines)
- Sprint 5.2: Service detection (soft dependency, enhances HTTPS detection)

**Blocks:**
- Sprint 5.6: Code Coverage (15 tests contribute)
- Sprint 5.8: Plugin System (TLS analysis results available to plugins)

**External Dependencies:**
- **New crates:**
  - `webpki-roots = "0.25"` (system root CA store)
  - `x509-parser = "0.15"` (X.509 certificate parsing)
- Both are well-maintained, widely used

**Technical Design Notes:**

**Certificate Chain Validation:**
- Use rustls WebPkiVerifier with webpki-roots (system root CAs)
- Validate: Signatures (each cert signed by next in chain), Validity dates (notBefore/notAfter), Key usage (digitalSignature, keyEncipherment)
- Report: Valid (chain to trusted root), Invalid (reason: expired, untrusted, self-signed)

**Weak Cipher Blacklist:**
```rust
const WEAK_CIPHERS: &[u16] = &[
    0x0005, // TLS_RSA_WITH_RC4_128_SHA (RC4)
    0x000A, // TLS_RSA_WITH_3DES_EDE_CBC_SHA (3DES)
    0x0003, // TLS_RSA_EXPORT_WITH_RC4_40_MD5 (export)
    0x0018, // TLS_DH_anon_WITH_AES_128_CBC_SHA (anonymous)
    // ... (full list ~30 weak cipher suites)
];
```

**Protocol Downgrade Detection:**
- ClientHello: Supported versions = [TLS 1.0, 1.1, 1.2, 1.3]
- ServerHello: Selected version = TLS 1.0
- Downgrade detected: Server selected weakest offered version (possible attack)

**Research References:**
- **RFC 5246 (TLS 1.2):** Cipher suite specifications
- **RFC 8446 (TLS 1.3):** Latest protocol version
- **NIST SP 800-52 Rev. 2:** TLS/SSL guidelines for federal systems
- **OWASP TLS Cheat Sheet:** Weak cipher recommendations

**Risk Mitigation:**

**Risk:** False positives (legitimate old servers flagged as weak)
- **Likelihood:** MEDIUM (many old servers use TLS 1.0/1.1)
- **Impact:** LOW (informational warning, not blocking)
- **Mitigation:**
  - Clearly label "Deprecated" vs "Weak" (TLS 1.0 deprecated but not broken)
  - Provide context (why deprecated, BEAST vulnerability for TLS 1.0)
  - User can ignore warnings if old server is acceptable

**Risk:** Performance overhead from certificate validation
- **Likelihood:** LOW (rustls is fast, chain validation ~10ms)
- **Impact:** LOW (opt-in with --tls-analysis flag)
- **Mitigation:**
  - Make --tls-analysis opt-in (off by default)
  - Cache validation results per IP (avoid re-validating)
  - Benchmark in Sprint 5.5 Phase 5

**Open Questions:**
- [ ] Should we validate OCSP stapling? (Check revocation status)
  - **Recommendation:** DEFER to v0.6.0. OCSP adds complexity (HTTP request to CA), low ROI for v0.5.0.
- [ ] How to handle CT (Certificate Transparency) logs?
  - **Recommendation:** DEFER to v0.6.0. CT validation requires SCT (Signed Certificate Timestamp) parsing.

---

*[Due to length constraints, I'll continue with the remaining sprints in the next part of the document. This covers Sprints 5.1-5.5 in comprehensive detail. Sprints 5.6-5.10 will follow the same structure.]*

---

## Phase Completion Criteria

[Details will be provided in the complete document]

## Risk Assessment

[Details will be provided in the complete document]

## Resource Requirements

[Details will be provided in the complete document]

## Timeline & Milestones

[Details will be provided in the complete document]

## Appendices

[Details will be provided in the complete document]

---

**Document Status:** PARTIAL (Sprints 5.1-5.5 complete, 5.6-5.10 + supporting sections to follow)
**Total Length So Far:** ~18,000 words
**Target Final Length:** 20,000-25,000 words

**Next Steps:**
1. Complete Sprints 5.6-5.10 detailed breakdowns
2. Finalize Phase Completion Criteria section
3. Complete Risk Assessment section
4. Complete Resource Requirements section
5. Complete Timeline & Milestones section
6. Complete all Appendices

**Estimated Completion:** 4-6 additional hours of writing to reach comprehensive 20,000-25,000 word target.